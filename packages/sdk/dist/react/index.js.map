{"version":3,"sources":["../../src/react/index.ts","../../src/react/provider.tsx","../../src/client.ts","../../src/react/hooks/useContacts.ts","../../src/react/hooks/useOrganizations.ts","../../src/react/hooks/useEvents.ts","../../src/react/hooks/useForms.ts","../../src/react/hooks/useCheckout.ts","../../src/react/hooks/useOrders.ts","../../src/react/hooks/useInvoices.ts","../../src/react/hooks/useBenefits.ts","../../src/react/hooks/useCertificates.ts"],"sourcesContent":["/**\n * @l4yercak3/sdk/react\n *\n * React bindings for the LayerCake SDK.\n * Includes the provider component and all domain hooks.\n *\n * @example\n * ```tsx\n * // In your app/layout.tsx\n * import { L4yercak3Provider } from '@l4yercak3/sdk/react';\n *\n * export default function RootLayout({ children }) {\n *   return (\n *     <html>\n *       <body>\n *         <L4yercak3Provider>\n *           {children}\n *         </L4yercak3Provider>\n *       </body>\n *     </html>\n *   );\n * }\n *\n * // In your components\n * import { useContacts, useEvents, useCheckout } from '@l4yercak3/sdk/react';\n *\n * function MyComponent() {\n *   const { contacts, fetchContacts } = useContacts();\n *   const { events } = useEvents();\n *   const { addToCart, createCheckoutSession } = useCheckout();\n *   // ...\n * }\n * ```\n */\n\n// Provider\nexport {\n  L4yercak3Provider,\n  useL4yercak3,\n  useL4yercak3Client,\n  type L4yercak3ProviderProps,\n} from './provider';\n\n// All hooks\nexport * from './hooks';\n","'use client';\n\nimport { createContext, useContext, useMemo, type ReactNode } from 'react';\nimport { L4yercak3Client, type L4yercak3ClientConfig } from '../client';\n\ninterface L4yercak3ContextValue {\n  client: L4yercak3Client;\n  organizationId?: string;\n}\n\nconst L4yercak3Context = createContext<L4yercak3ContextValue | null>(null);\n\nexport interface L4yercak3ProviderProps {\n  children: ReactNode;\n  /** API key for authentication. If not provided, uses NEXT_PUBLIC_L4YERCAK3_API_KEY */\n  apiKey?: string;\n  /** Organization ID to scope requests. If not provided, uses L4YERCAK3_ORG_ID */\n  organizationId?: string;\n  /** Base URL for the API. If not provided, uses NEXT_PUBLIC_L4YERCAK3_URL */\n  baseUrl?: string;\n  /** Pre-configured client instance (optional, overrides other props) */\n  client?: L4yercak3Client;\n}\n\n/**\n * Provider component for LayerCake SDK.\n * Wrap your app with this provider to use the SDK hooks.\n *\n * @example\n * ```tsx\n * // In your app/layout.tsx\n * import { L4yercak3Provider } from '@l4yercak3/sdk/react';\n *\n * export default function RootLayout({ children }) {\n *   return (\n *     <html>\n *       <body>\n *         <L4yercak3Provider>\n *           {children}\n *         </L4yercak3Provider>\n *       </body>\n *     </html>\n *   );\n * }\n * ```\n */\nexport function L4yercak3Provider({\n  children,\n  apiKey,\n  organizationId,\n  baseUrl,\n  client: providedClient,\n}: L4yercak3ProviderProps) {\n  const client = useMemo(() => {\n    if (providedClient) {\n      return providedClient;\n    }\n\n    const config: L4yercak3ClientConfig = {};\n    if (apiKey) config.apiKey = apiKey;\n    if (organizationId) config.organizationId = organizationId;\n    if (baseUrl) config.baseUrl = baseUrl;\n\n    return new L4yercak3Client(config);\n  }, [providedClient, apiKey, organizationId, baseUrl]);\n\n  const value = useMemo(\n    () => ({\n      client,\n      organizationId,\n    }),\n    [client, organizationId]\n  );\n\n  return (\n    <L4yercak3Context.Provider value={value}>\n      {children}\n    </L4yercak3Context.Provider>\n  );\n}\n\n/**\n * Hook to access the LayerCake client and context.\n * Must be used within a L4yercak3Provider.\n *\n * @example\n * ```tsx\n * function MyComponent() {\n *   const { client } = useL4yercak3();\n *   // Use client.contacts, client.events, etc.\n * }\n * ```\n */\nexport function useL4yercak3(): L4yercak3ContextValue {\n  const context = useContext(L4yercak3Context);\n  if (!context) {\n    throw new Error('useL4yercak3 must be used within a L4yercak3Provider');\n  }\n  return context;\n}\n\n/**\n * Hook to get just the client instance.\n * Convenience wrapper around useL4yercak3().\n */\nexport function useL4yercak3Client(): L4yercak3Client {\n  const { client } = useL4yercak3();\n  return client;\n}\n","/**\n * @l4yercak3/sdk API Client\n *\n * A fully-typed API client for the LayerCake platform.\n */\n\nimport type {\n  Contact,\n  ContactCreateInput,\n  ContactUpdateInput,\n  ContactListParams,\n  Organization,\n  OrganizationCreateInput,\n  OrganizationListParams,\n  Event,\n  EventCreateInput,\n  EventListParams,\n  Attendee,\n  AttendeeListParams,\n  Form,\n  FormSubmission,\n  FormListParams,\n  FormSubmissionListParams,\n  Product,\n  ProductListParams,\n  Order,\n  OrderListParams,\n  CheckoutSession,\n  CheckoutSessionCreateInput,\n  Invoice,\n  InvoiceCreateInput,\n  InvoiceListParams,\n  BenefitClaim,\n  BenefitClaimInput,\n  BenefitClaimListParams,\n  CommissionPayout,\n  CommissionPayoutListParams,\n  Certificate,\n  PaginatedResponse,\n} from './types';\n\nconst DEFAULT_BASE_URL = 'https://agreeable-lion-828.convex.site';\n\nexport interface L4yercak3ClientConfig {\n  /** API key for authentication */\n  apiKey?: string;\n  /** Base URL for the API (defaults to production) */\n  baseUrl?: string;\n  /** Organization ID to scope requests to */\n  organizationId?: string;\n}\n\nexport class L4yercak3Client {\n  private apiKey: string;\n  private baseUrl: string;\n  private organizationId?: string;\n\n  public readonly contacts: ContactsAPI;\n  public readonly organizations: OrganizationsAPI;\n  public readonly events: EventsAPI;\n  public readonly forms: FormsAPI;\n  public readonly products: ProductsAPI;\n  public readonly checkout: CheckoutAPI;\n  public readonly orders: OrdersAPI;\n  public readonly invoices: InvoicesAPI;\n  public readonly benefits: BenefitsAPI;\n  public readonly certificates: CertificatesAPI;\n\n  constructor(config: L4yercak3ClientConfig = {}) {\n    this.apiKey = config.apiKey || this.getEnvVar('NEXT_PUBLIC_L4YERCAK3_API_KEY') || this.getEnvVar('L4YERCAK3_API_KEY') || '';\n    this.baseUrl = config.baseUrl || this.getEnvVar('NEXT_PUBLIC_L4YERCAK3_URL') || DEFAULT_BASE_URL;\n    this.organizationId = config.organizationId || this.getEnvVar('L4YERCAK3_ORG_ID');\n\n    if (!this.apiKey) {\n      console.warn('[@l4yercak3/sdk] No API key provided. Set NEXT_PUBLIC_L4YERCAK3_API_KEY or pass apiKey to constructor.');\n    }\n\n    // Initialize domain APIs\n    this.contacts = new ContactsAPI(this);\n    this.organizations = new OrganizationsAPI(this);\n    this.events = new EventsAPI(this);\n    this.forms = new FormsAPI(this);\n    this.products = new ProductsAPI(this);\n    this.checkout = new CheckoutAPI(this);\n    this.orders = new OrdersAPI(this);\n    this.invoices = new InvoicesAPI(this);\n    this.benefits = new BenefitsAPI(this);\n    this.certificates = new CertificatesAPI(this);\n  }\n\n  private getEnvVar(name: string): string | undefined {\n    if (typeof process !== 'undefined' && process.env) {\n      return process.env[name];\n    }\n    return undefined;\n  }\n\n  /** Make a raw API request */\n  async request<T, P extends Record<string, unknown> = Record<string, unknown>>(\n    method: string,\n    path: string,\n    options?: {\n      params?: P;\n      body?: unknown;\n    }\n  ): Promise<T> {\n    const url = new URL(path, this.baseUrl);\n\n    if (options?.params) {\n      Object.entries(options.params).forEach(([key, value]) => {\n        if (value !== undefined && value !== null) {\n          if (Array.isArray(value)) {\n            value.forEach((v) => url.searchParams.append(key, String(v)));\n          } else {\n            url.searchParams.set(key, String(value));\n          }\n        }\n      });\n    }\n\n    const headers: Record<string, string> = {\n      'Content-Type': 'application/json',\n    };\n\n    if (this.apiKey) {\n      headers['Authorization'] = `Bearer ${this.apiKey}`;\n    }\n\n    if (this.organizationId) {\n      headers['X-Organization-Id'] = this.organizationId;\n    }\n\n    const response = await fetch(url.toString(), {\n      method,\n      headers,\n      body: options?.body ? JSON.stringify(options.body) : undefined,\n    });\n\n    if (!response.ok) {\n      const error = await response.json().catch(() => ({}));\n      throw new L4yercak3Error(\n        response.status,\n        error.message || `Request failed: ${response.status}`,\n        error.code,\n        error\n      );\n    }\n\n    // Handle 204 No Content\n    if (response.status === 204) {\n      return undefined as T;\n    }\n\n    return response.json();\n  }\n}\n\n// ============ Domain APIs ============\n\nclass ContactsAPI {\n  constructor(private client: L4yercak3Client) {}\n\n  /** List contacts with optional filtering */\n  async list(params?: ContactListParams): Promise<PaginatedResponse<Contact>> {\n    return this.client.request('GET', '/api/v1/crm/contacts', { params });\n  }\n\n  /** Get a single contact by ID */\n  async get(\n    id: string,\n    options?: {\n      includeActivities?: boolean;\n      includeNotes?: boolean;\n      includeOrganization?: boolean;\n    }\n  ): Promise<Contact> {\n    return this.client.request('GET', `/api/v1/crm/contacts/${id}`, { params: options });\n  }\n\n  /** Create a new contact */\n  async create(data: ContactCreateInput): Promise<Contact> {\n    return this.client.request('POST', '/api/v1/crm/contacts', { body: data });\n  }\n\n  /** Update an existing contact */\n  async update(id: string, data: ContactUpdateInput): Promise<Contact> {\n    return this.client.request('PATCH', `/api/v1/crm/contacts/${id}`, { body: data });\n  }\n\n  /** Delete a contact */\n  async delete(id: string): Promise<void> {\n    return this.client.request('DELETE', `/api/v1/crm/contacts/${id}`);\n  }\n\n  /** Add tags to a contact */\n  async addTags(id: string, tags: string[]): Promise<Contact> {\n    return this.client.request('POST', `/api/v1/crm/contacts/${id}/tags`, { body: { tags } });\n  }\n\n  /** Remove tags from a contact */\n  async removeTags(id: string, tags: string[]): Promise<Contact> {\n    return this.client.request('DELETE', `/api/v1/crm/contacts/${id}/tags`, { body: { tags } });\n  }\n}\n\nclass OrganizationsAPI {\n  constructor(private client: L4yercak3Client) {}\n\n  /** List organizations with optional filtering */\n  async list(params?: OrganizationListParams): Promise<PaginatedResponse<Organization>> {\n    return this.client.request('GET', '/api/v1/crm/organizations', { params });\n  }\n\n  /** Get a single organization by ID */\n  async get(id: string, options?: { includeContacts?: boolean }): Promise<Organization> {\n    return this.client.request('GET', `/api/v1/crm/organizations/${id}`, { params: options });\n  }\n\n  /** Create a new organization */\n  async create(data: OrganizationCreateInput): Promise<Organization> {\n    return this.client.request('POST', '/api/v1/crm/organizations', { body: data });\n  }\n\n  /** Update an existing organization */\n  async update(id: string, data: Partial<OrganizationCreateInput>): Promise<Organization> {\n    return this.client.request('PATCH', `/api/v1/crm/organizations/${id}`, { body: data });\n  }\n\n  /** Delete an organization */\n  async delete(id: string): Promise<void> {\n    return this.client.request('DELETE', `/api/v1/crm/organizations/${id}`);\n  }\n}\n\nclass EventsAPI {\n  constructor(private client: L4yercak3Client) {}\n\n  /** List events with optional filtering */\n  async list(params?: EventListParams): Promise<PaginatedResponse<Event>> {\n    return this.client.request('GET', '/api/v1/events', { params });\n  }\n\n  /** Get a single event by ID */\n  async get(\n    id: string,\n    options?: {\n      includeProducts?: boolean;\n      includeSponsors?: boolean;\n      includeForms?: boolean;\n    }\n  ): Promise<Event> {\n    return this.client.request('GET', `/api/v1/events/${id}`, { params: options });\n  }\n\n  /** Create a new event */\n  async create(data: EventCreateInput): Promise<Event> {\n    return this.client.request('POST', '/api/v1/events', { body: data });\n  }\n\n  /** Update an existing event */\n  async update(id: string, data: Partial<EventCreateInput>): Promise<Event> {\n    return this.client.request('PATCH', `/api/v1/events/${id}`, { body: data });\n  }\n\n  /** Delete an event */\n  async delete(id: string): Promise<void> {\n    return this.client.request('DELETE', `/api/v1/events/${id}`);\n  }\n\n  /** Get attendees for an event */\n  async getAttendees(eventId: string, params?: AttendeeListParams): Promise<PaginatedResponse<Attendee>> {\n    return this.client.request('GET', `/api/v1/events/${eventId}/attendees`, { params });\n  }\n\n  /** Check in an attendee */\n  async checkInAttendee(eventId: string, attendeeId: string): Promise<Attendee> {\n    return this.client.request('POST', `/api/v1/events/${eventId}/attendees/${attendeeId}/check-in`);\n  }\n\n  /** Cancel an attendee's registration */\n  async cancelAttendee(eventId: string, attendeeId: string): Promise<Attendee> {\n    return this.client.request('POST', `/api/v1/events/${eventId}/attendees/${attendeeId}/cancel`);\n  }\n}\n\nclass FormsAPI {\n  constructor(private client: L4yercak3Client) {}\n\n  /** List forms with optional filtering */\n  async list(params?: FormListParams): Promise<PaginatedResponse<Form>> {\n    return this.client.request('GET', '/api/v1/forms', { params });\n  }\n\n  /** Get a single form by ID */\n  async get(id: string): Promise<Form> {\n    return this.client.request('GET', `/api/v1/forms/${id}`);\n  }\n\n  /** Submit a form response */\n  async submit(formId: string, data: Record<string, unknown>): Promise<FormSubmission> {\n    return this.client.request('POST', `/api/v1/forms/${formId}/submit`, { body: data });\n  }\n\n  /** Get submissions for a form */\n  async getSubmissions(formId: string, params?: FormSubmissionListParams): Promise<PaginatedResponse<FormSubmission>> {\n    return this.client.request('GET', `/api/v1/forms/${formId}/responses`, { params });\n  }\n\n  /** Get a single submission by ID */\n  async getSubmission(formId: string, submissionId: string): Promise<FormSubmission> {\n    return this.client.request('GET', `/api/v1/forms/${formId}/responses/${submissionId}`);\n  }\n}\n\nclass ProductsAPI {\n  constructor(private client: L4yercak3Client) {}\n\n  /** List products with optional filtering */\n  async list(params?: ProductListParams): Promise<PaginatedResponse<Product>> {\n    return this.client.request('GET', '/api/v1/products', { params });\n  }\n\n  /** Get a single product by ID */\n  async get(id: string): Promise<Product> {\n    return this.client.request('GET', `/api/v1/products/${id}`);\n  }\n}\n\nclass CheckoutAPI {\n  constructor(private client: L4yercak3Client) {}\n\n  /** Create a new checkout session */\n  async createSession(data: CheckoutSessionCreateInput): Promise<CheckoutSession> {\n    return this.client.request('POST', '/api/v1/checkout/sessions', { body: data });\n  }\n\n  /** Get a checkout session by ID */\n  async getSession(sessionId: string): Promise<CheckoutSession> {\n    return this.client.request('GET', `/api/v1/checkout/sessions/${sessionId}`);\n  }\n}\n\nclass OrdersAPI {\n  constructor(private client: L4yercak3Client) {}\n\n  /** List orders with optional filtering */\n  async list(params?: OrderListParams): Promise<PaginatedResponse<Order>> {\n    return this.client.request('GET', '/api/v1/orders', { params });\n  }\n\n  /** Get a single order by ID */\n  async get(id: string): Promise<Order> {\n    return this.client.request('GET', `/api/v1/orders/${id}`);\n  }\n\n  /** Get an order by order number */\n  async getByOrderNumber(orderNumber: string): Promise<Order> {\n    return this.client.request('GET', `/api/v1/orders/by-number/${orderNumber}`);\n  }\n}\n\nclass InvoicesAPI {\n  constructor(private client: L4yercak3Client) {}\n\n  /** List invoices with optional filtering */\n  async list(params?: InvoiceListParams): Promise<PaginatedResponse<Invoice>> {\n    return this.client.request('GET', '/api/v1/invoices', { params });\n  }\n\n  /** Get a single invoice by ID */\n  async get(id: string): Promise<Invoice> {\n    return this.client.request('GET', `/api/v1/invoices/${id}`);\n  }\n\n  /** Create a new invoice */\n  async create(data: InvoiceCreateInput): Promise<Invoice> {\n    return this.client.request('POST', '/api/v1/invoices', { body: data });\n  }\n\n  /** Send an invoice */\n  async send(id: string, options?: { emailTo?: string; message?: string }): Promise<void> {\n    return this.client.request('POST', `/api/v1/invoices/${id}/send`, { body: options });\n  }\n\n  /** Mark an invoice as paid */\n  async markPaid(\n    id: string,\n    data?: {\n      paidAt?: string;\n      paymentMethod?: string;\n      paymentReference?: string;\n    }\n  ): Promise<Invoice> {\n    return this.client.request('POST', `/api/v1/invoices/${id}/mark-paid`, { body: data });\n  }\n\n  /** Get the PDF URL for an invoice */\n  async getPdf(id: string): Promise<{ pdfUrl: string }> {\n    return this.client.request('GET', `/api/v1/invoices/${id}/pdf`);\n  }\n\n  /** Void an invoice */\n  async void(id: string): Promise<Invoice> {\n    return this.client.request('POST', `/api/v1/invoices/${id}/void`);\n  }\n}\n\nclass BenefitsAPI {\n  constructor(private client: L4yercak3Client) {}\n\n  /** List benefit claims with optional filtering */\n  async listClaims(params?: BenefitClaimListParams): Promise<PaginatedResponse<BenefitClaim>> {\n    return this.client.request('GET', '/api/v1/benefits/claims', { params });\n  }\n\n  /** Get a single benefit claim by ID */\n  async getClaim(id: string): Promise<BenefitClaim> {\n    return this.client.request('GET', `/api/v1/benefits/claims/${id}`);\n  }\n\n  /** Create a new benefit claim */\n  async createClaim(data: BenefitClaimInput): Promise<BenefitClaim> {\n    return this.client.request('POST', '/api/v1/benefits/claims', { body: data });\n  }\n\n  /** Approve a benefit claim */\n  async approveClaim(id: string, notes?: string): Promise<BenefitClaim> {\n    return this.client.request('POST', `/api/v1/benefits/claims/${id}/approve`, { body: { notes } });\n  }\n\n  /** Reject a benefit claim */\n  async rejectClaim(id: string, reason: string): Promise<BenefitClaim> {\n    return this.client.request('POST', `/api/v1/benefits/claims/${id}/reject`, { body: { reason } });\n  }\n\n  /** List commission payouts with optional filtering */\n  async listCommissions(params?: CommissionPayoutListParams): Promise<PaginatedResponse<CommissionPayout>> {\n    return this.client.request('GET', '/api/v1/benefits/commissions', { params });\n  }\n\n  /** Get a single commission payout by ID */\n  async getCommission(id: string): Promise<CommissionPayout> {\n    return this.client.request('GET', `/api/v1/benefits/commissions/${id}`);\n  }\n}\n\nclass CertificatesAPI {\n  constructor(private client: L4yercak3Client) {}\n\n  /** List certificates */\n  async list(params?: { recipientId?: string; eventId?: string; limit?: number }): Promise<PaginatedResponse<Certificate>> {\n    return this.client.request('GET', '/api/v1/certificates', { params });\n  }\n\n  /** Get a single certificate by ID */\n  async get(id: string): Promise<Certificate> {\n    return this.client.request('GET', `/api/v1/certificates/${id}`);\n  }\n\n  /** Verify a certificate by certificate number */\n  async verify(certificateNumber: string): Promise<Certificate> {\n    return this.client.request('GET', `/api/v1/certificates/verify/${certificateNumber}`);\n  }\n}\n\n// ============ Error Class ============\n\nexport class L4yercak3Error extends Error {\n  constructor(\n    public status: number,\n    message: string,\n    public code?: string,\n    public details?: unknown\n  ) {\n    super(message);\n    this.name = 'L4yercak3Error';\n  }\n}\n\n// ============ Singleton Helper ============\n\nlet defaultClient: L4yercak3Client | null = null;\n\n/**\n * Get the default L4yercak3Client instance.\n * Creates one if it doesn't exist, using environment variables for configuration.\n */\nexport function getL4yercak3Client(): L4yercak3Client {\n  if (!defaultClient) {\n    defaultClient = new L4yercak3Client();\n  }\n  return defaultClient;\n}\n\n/**\n * Create a new L4yercak3Client instance with custom configuration.\n */\nexport function createL4yercak3Client(config: L4yercak3ClientConfig): L4yercak3Client {\n  return new L4yercak3Client(config);\n}\n","'use client';\n\nimport { useState, useCallback } from 'react';\nimport { useL4yercak3Client } from '../provider';\nimport type {\n  Contact,\n  ContactCreateInput,\n  ContactUpdateInput,\n  ContactListParams,\n  PaginatedResponse,\n} from '../../types';\n\nexport interface UseContactsResult {\n  /** Current list of contacts */\n  contacts: Contact[];\n  /** Whether a request is in progress */\n  loading: boolean;\n  /** Last error that occurred */\n  error: Error | null;\n  /** Total count of contacts (from last fetch) */\n  total: number;\n  /** Whether there are more contacts to load */\n  hasMore: boolean;\n  /** Fetch contacts with optional filters */\n  fetchContacts: (params?: ContactListParams) => Promise<PaginatedResponse<Contact>>;\n  /** Get a single contact by ID */\n  getContact: (id: string) => Promise<Contact>;\n  /** Create a new contact */\n  createContact: (data: ContactCreateInput) => Promise<Contact>;\n  /** Update an existing contact */\n  updateContact: (id: string, data: ContactUpdateInput) => Promise<Contact>;\n  /** Delete a contact */\n  deleteContact: (id: string) => Promise<void>;\n  /** Add tags to a contact */\n  addTags: (id: string, tags: string[]) => Promise<Contact>;\n  /** Remove tags from a contact */\n  removeTags: (id: string, tags: string[]) => Promise<Contact>;\n  /** Reset error state */\n  clearError: () => void;\n}\n\n/**\n * Hook for managing contacts in your LayerCake CRM.\n *\n * @example\n * ```tsx\n * function ContactList() {\n *   const { contacts, loading, error, fetchContacts } = useContacts();\n *\n *   useEffect(() => {\n *     fetchContacts({ status: 'active' });\n *   }, []);\n *\n *   if (loading) return <div>Loading...</div>;\n *   if (error) return <div>Error: {error.message}</div>;\n *\n *   return (\n *     <ul>\n *       {contacts.map(contact => (\n *         <li key={contact.id}>{contact.firstName} {contact.lastName}</li>\n *       ))}\n *     </ul>\n *   );\n * }\n * ```\n */\nexport function useContacts(): UseContactsResult {\n  const client = useL4yercak3Client();\n  const [contacts, setContacts] = useState<Contact[]>([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n  const [total, setTotal] = useState(0);\n  const [hasMore, setHasMore] = useState(false);\n\n  const fetchContacts = useCallback(\n    async (params?: ContactListParams): Promise<PaginatedResponse<Contact>> => {\n      setLoading(true);\n      setError(null);\n      try {\n        const result = await client.contacts.list(params);\n        setContacts(result.items);\n        setTotal(result.total);\n        setHasMore(result.hasMore);\n        return result;\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const getContact = useCallback(\n    async (id: string): Promise<Contact> => {\n      setLoading(true);\n      setError(null);\n      try {\n        return await client.contacts.get(id);\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const createContact = useCallback(\n    async (data: ContactCreateInput): Promise<Contact> => {\n      setLoading(true);\n      setError(null);\n      try {\n        const contact = await client.contacts.create(data);\n        setContacts((prev) => [...prev, contact]);\n        setTotal((prev) => prev + 1);\n        return contact;\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const updateContact = useCallback(\n    async (id: string, data: ContactUpdateInput): Promise<Contact> => {\n      setLoading(true);\n      setError(null);\n      try {\n        const updated = await client.contacts.update(id, data);\n        setContacts((prev) => prev.map((c) => (c.id === id ? updated : c)));\n        return updated;\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const deleteContact = useCallback(\n    async (id: string): Promise<void> => {\n      setLoading(true);\n      setError(null);\n      try {\n        await client.contacts.delete(id);\n        setContacts((prev) => prev.filter((c) => c.id !== id));\n        setTotal((prev) => prev - 1);\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const addTags = useCallback(\n    async (id: string, tags: string[]): Promise<Contact> => {\n      setLoading(true);\n      setError(null);\n      try {\n        const updated = await client.contacts.addTags(id, tags);\n        setContacts((prev) => prev.map((c) => (c.id === id ? updated : c)));\n        return updated;\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const removeTags = useCallback(\n    async (id: string, tags: string[]): Promise<Contact> => {\n      setLoading(true);\n      setError(null);\n      try {\n        const updated = await client.contacts.removeTags(id, tags);\n        setContacts((prev) => prev.map((c) => (c.id === id ? updated : c)));\n        return updated;\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const clearError = useCallback(() => {\n    setError(null);\n  }, []);\n\n  return {\n    contacts,\n    loading,\n    error,\n    total,\n    hasMore,\n    fetchContacts,\n    getContact,\n    createContact,\n    updateContact,\n    deleteContact,\n    addTags,\n    removeTags,\n    clearError,\n  };\n}\n","'use client';\n\nimport { useState, useCallback } from 'react';\nimport { useL4yercak3Client } from '../provider';\nimport type {\n  Organization,\n  OrganizationCreateInput,\n  OrganizationListParams,\n  PaginatedResponse,\n} from '../../types';\n\nexport interface UseOrganizationsResult {\n  /** Current list of organizations */\n  organizations: Organization[];\n  /** Whether a request is in progress */\n  loading: boolean;\n  /** Last error that occurred */\n  error: Error | null;\n  /** Total count of organizations (from last fetch) */\n  total: number;\n  /** Whether there are more organizations to load */\n  hasMore: boolean;\n  /** Fetch organizations with optional filters */\n  fetchOrganizations: (params?: OrganizationListParams) => Promise<PaginatedResponse<Organization>>;\n  /** Get a single organization by ID */\n  getOrganization: (id: string, options?: { includeContacts?: boolean }) => Promise<Organization>;\n  /** Create a new organization */\n  createOrganization: (data: OrganizationCreateInput) => Promise<Organization>;\n  /** Update an existing organization */\n  updateOrganization: (id: string, data: Partial<OrganizationCreateInput>) => Promise<Organization>;\n  /** Delete an organization */\n  deleteOrganization: (id: string) => Promise<void>;\n  /** Reset error state */\n  clearError: () => void;\n}\n\n/**\n * Hook for managing B2B organizations in your CRM.\n *\n * @example\n * ```tsx\n * function OrganizationList() {\n *   const { organizations, loading, fetchOrganizations } = useOrganizations();\n *\n *   useEffect(() => {\n *     fetchOrganizations({ subtype: 'customer' });\n *   }, []);\n *\n *   return (\n *     <ul>\n *       {organizations.map(org => (\n *         <li key={org.id}>{org.name}</li>\n *       ))}\n *     </ul>\n *   );\n * }\n * ```\n */\nexport function useOrganizations(): UseOrganizationsResult {\n  const client = useL4yercak3Client();\n  const [organizations, setOrganizations] = useState<Organization[]>([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n  const [total, setTotal] = useState(0);\n  const [hasMore, setHasMore] = useState(false);\n\n  const fetchOrganizations = useCallback(\n    async (params?: OrganizationListParams): Promise<PaginatedResponse<Organization>> => {\n      setLoading(true);\n      setError(null);\n      try {\n        const result = await client.organizations.list(params);\n        setOrganizations(result.items);\n        setTotal(result.total);\n        setHasMore(result.hasMore);\n        return result;\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const getOrganization = useCallback(\n    async (id: string, options?: { includeContacts?: boolean }): Promise<Organization> => {\n      setLoading(true);\n      setError(null);\n      try {\n        return await client.organizations.get(id, options);\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const createOrganization = useCallback(\n    async (data: OrganizationCreateInput): Promise<Organization> => {\n      setLoading(true);\n      setError(null);\n      try {\n        const org = await client.organizations.create(data);\n        setOrganizations((prev) => [...prev, org]);\n        setTotal((prev) => prev + 1);\n        return org;\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const updateOrganization = useCallback(\n    async (id: string, data: Partial<OrganizationCreateInput>): Promise<Organization> => {\n      setLoading(true);\n      setError(null);\n      try {\n        const updated = await client.organizations.update(id, data);\n        setOrganizations((prev) => prev.map((o) => (o.id === id ? updated : o)));\n        return updated;\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const deleteOrganization = useCallback(\n    async (id: string): Promise<void> => {\n      setLoading(true);\n      setError(null);\n      try {\n        await client.organizations.delete(id);\n        setOrganizations((prev) => prev.filter((o) => o.id !== id));\n        setTotal((prev) => prev - 1);\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const clearError = useCallback(() => {\n    setError(null);\n  }, []);\n\n  return {\n    organizations,\n    loading,\n    error,\n    total,\n    hasMore,\n    fetchOrganizations,\n    getOrganization,\n    createOrganization,\n    updateOrganization,\n    deleteOrganization,\n    clearError,\n  };\n}\n","'use client';\n\nimport { useState, useCallback } from 'react';\nimport { useL4yercak3Client } from '../provider';\nimport type {\n  Event,\n  EventCreateInput,\n  EventListParams,\n  Attendee,\n  AttendeeListParams,\n  PaginatedResponse,\n} from '../../types';\n\nexport interface UseEventsResult {\n  /** Current list of events */\n  events: Event[];\n  /** Whether a request is in progress */\n  loading: boolean;\n  /** Last error that occurred */\n  error: Error | null;\n  /** Total count of events (from last fetch) */\n  total: number;\n  /** Whether there are more events to load */\n  hasMore: boolean;\n  /** Fetch events with optional filters */\n  fetchEvents: (params?: EventListParams) => Promise<PaginatedResponse<Event>>;\n  /** Get a single event by ID */\n  getEvent: (id: string, options?: { includeProducts?: boolean; includeSponsors?: boolean; includeForms?: boolean }) => Promise<Event>;\n  /** Create a new event */\n  createEvent: (data: EventCreateInput) => Promise<Event>;\n  /** Update an existing event */\n  updateEvent: (id: string, data: Partial<EventCreateInput>) => Promise<Event>;\n  /** Delete an event */\n  deleteEvent: (id: string) => Promise<void>;\n  /** Reset error state */\n  clearError: () => void;\n}\n\n/**\n * Hook for managing events.\n *\n * @example\n * ```tsx\n * function EventList() {\n *   const { events, loading, fetchEvents } = useEvents();\n *\n *   useEffect(() => {\n *     fetchEvents({ status: 'published' });\n *   }, []);\n *\n *   return (\n *     <div>\n *       {events.map(event => (\n *         <EventCard key={event.id} event={event} />\n *       ))}\n *     </div>\n *   );\n * }\n * ```\n */\nexport function useEvents(): UseEventsResult {\n  const client = useL4yercak3Client();\n  const [events, setEvents] = useState<Event[]>([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n  const [total, setTotal] = useState(0);\n  const [hasMore, setHasMore] = useState(false);\n\n  const fetchEvents = useCallback(\n    async (params?: EventListParams): Promise<PaginatedResponse<Event>> => {\n      setLoading(true);\n      setError(null);\n      try {\n        const result = await client.events.list(params);\n        setEvents(result.items);\n        setTotal(result.total);\n        setHasMore(result.hasMore);\n        return result;\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const getEvent = useCallback(\n    async (\n      id: string,\n      options?: { includeProducts?: boolean; includeSponsors?: boolean; includeForms?: boolean }\n    ): Promise<Event> => {\n      setLoading(true);\n      setError(null);\n      try {\n        return await client.events.get(id, options);\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const createEvent = useCallback(\n    async (data: EventCreateInput): Promise<Event> => {\n      setLoading(true);\n      setError(null);\n      try {\n        const event = await client.events.create(data);\n        setEvents((prev) => [...prev, event]);\n        setTotal((prev) => prev + 1);\n        return event;\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const updateEvent = useCallback(\n    async (id: string, data: Partial<EventCreateInput>): Promise<Event> => {\n      setLoading(true);\n      setError(null);\n      try {\n        const updated = await client.events.update(id, data);\n        setEvents((prev) => prev.map((e) => (e.id === id ? updated : e)));\n        return updated;\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const deleteEvent = useCallback(\n    async (id: string): Promise<void> => {\n      setLoading(true);\n      setError(null);\n      try {\n        await client.events.delete(id);\n        setEvents((prev) => prev.filter((e) => e.id !== id));\n        setTotal((prev) => prev - 1);\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const clearError = useCallback(() => {\n    setError(null);\n  }, []);\n\n  return {\n    events,\n    loading,\n    error,\n    total,\n    hasMore,\n    fetchEvents,\n    getEvent,\n    createEvent,\n    updateEvent,\n    deleteEvent,\n    clearError,\n  };\n}\n\nexport interface UseAttendeesResult {\n  /** Current list of attendees */\n  attendees: Attendee[];\n  /** Whether a request is in progress */\n  loading: boolean;\n  /** Last error that occurred */\n  error: Error | null;\n  /** Total count of attendees (from last fetch) */\n  total: number;\n  /** Whether there are more attendees to load */\n  hasMore: boolean;\n  /** Fetch attendees for an event */\n  fetchAttendees: (eventId: string, params?: AttendeeListParams) => Promise<PaginatedResponse<Attendee>>;\n  /** Check in an attendee */\n  checkIn: (eventId: string, attendeeId: string) => Promise<Attendee>;\n  /** Cancel an attendee's registration */\n  cancelRegistration: (eventId: string, attendeeId: string) => Promise<Attendee>;\n  /** Reset error state */\n  clearError: () => void;\n}\n\n/**\n * Hook for managing event attendees.\n *\n * @example\n * ```tsx\n * function AttendeeList({ eventId }) {\n *   const { attendees, loading, fetchAttendees, checkIn } = useAttendees();\n *\n *   useEffect(() => {\n *     fetchAttendees(eventId);\n *   }, [eventId]);\n *\n *   const handleCheckIn = async (attendeeId) => {\n *     await checkIn(eventId, attendeeId);\n *   };\n *\n *   return (\n *     <ul>\n *       {attendees.map(attendee => (\n *         <li key={attendee.id}>\n *           {attendee.contact.firstName} - {attendee.status}\n *           {attendee.status !== 'checked_in' && (\n *             <button onClick={() => handleCheckIn(attendee.id)}>Check In</button>\n *           )}\n *         </li>\n *       ))}\n *     </ul>\n *   );\n * }\n * ```\n */\nexport function useAttendees(): UseAttendeesResult {\n  const client = useL4yercak3Client();\n  const [attendees, setAttendees] = useState<Attendee[]>([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n  const [total, setTotal] = useState(0);\n  const [hasMore, setHasMore] = useState(false);\n\n  const fetchAttendees = useCallback(\n    async (eventId: string, params?: AttendeeListParams): Promise<PaginatedResponse<Attendee>> => {\n      setLoading(true);\n      setError(null);\n      try {\n        const result = await client.events.getAttendees(eventId, params);\n        setAttendees(result.items);\n        setTotal(result.total);\n        setHasMore(result.hasMore);\n        return result;\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const checkIn = useCallback(\n    async (eventId: string, attendeeId: string): Promise<Attendee> => {\n      setLoading(true);\n      setError(null);\n      try {\n        const updated = await client.events.checkInAttendee(eventId, attendeeId);\n        setAttendees((prev) => prev.map((a) => (a.id === attendeeId ? updated : a)));\n        return updated;\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const cancelRegistration = useCallback(\n    async (eventId: string, attendeeId: string): Promise<Attendee> => {\n      setLoading(true);\n      setError(null);\n      try {\n        const updated = await client.events.cancelAttendee(eventId, attendeeId);\n        setAttendees((prev) => prev.map((a) => (a.id === attendeeId ? updated : a)));\n        return updated;\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const clearError = useCallback(() => {\n    setError(null);\n  }, []);\n\n  return {\n    attendees,\n    loading,\n    error,\n    total,\n    hasMore,\n    fetchAttendees,\n    checkIn,\n    cancelRegistration,\n    clearError,\n  };\n}\n","'use client';\n\nimport { useState, useCallback } from 'react';\nimport { useL4yercak3Client } from '../provider';\nimport type {\n  Form,\n  FormSubmission,\n  FormListParams,\n  FormSubmissionListParams,\n  PaginatedResponse,\n} from '../../types';\n\nexport interface UseFormsResult {\n  /** Current list of forms */\n  forms: Form[];\n  /** Whether a request is in progress */\n  loading: boolean;\n  /** Last error that occurred */\n  error: Error | null;\n  /** Total count of forms (from last fetch) */\n  total: number;\n  /** Whether there are more forms to load */\n  hasMore: boolean;\n  /** Fetch forms with optional filters */\n  fetchForms: (params?: FormListParams) => Promise<PaginatedResponse<Form>>;\n  /** Get a single form by ID */\n  getForm: (id: string) => Promise<Form>;\n  /** Reset error state */\n  clearError: () => void;\n}\n\n/**\n * Hook for managing forms.\n *\n * @example\n * ```tsx\n * function FormList() {\n *   const { forms, loading, fetchForms } = useForms();\n *\n *   useEffect(() => {\n *     fetchForms({ status: 'published' });\n *   }, []);\n *\n *   return (\n *     <div>\n *       {forms.map(form => (\n *         <FormCard key={form.id} form={form} />\n *       ))}\n *     </div>\n *   );\n * }\n * ```\n */\nexport function useForms(): UseFormsResult {\n  const client = useL4yercak3Client();\n  const [forms, setForms] = useState<Form[]>([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n  const [total, setTotal] = useState(0);\n  const [hasMore, setHasMore] = useState(false);\n\n  const fetchForms = useCallback(\n    async (params?: FormListParams): Promise<PaginatedResponse<Form>> => {\n      setLoading(true);\n      setError(null);\n      try {\n        const result = await client.forms.list(params);\n        setForms(result.items);\n        setTotal(result.total);\n        setHasMore(result.hasMore);\n        return result;\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const getForm = useCallback(\n    async (id: string): Promise<Form> => {\n      setLoading(true);\n      setError(null);\n      try {\n        return await client.forms.get(id);\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const clearError = useCallback(() => {\n    setError(null);\n  }, []);\n\n  return {\n    forms,\n    loading,\n    error,\n    total,\n    hasMore,\n    fetchForms,\n    getForm,\n    clearError,\n  };\n}\n\nexport interface UseFormSubmissionsResult {\n  /** Current list of submissions */\n  submissions: FormSubmission[];\n  /** Whether a request is in progress */\n  loading: boolean;\n  /** Whether a form is being submitted */\n  isSubmitting: boolean;\n  /** Last error that occurred */\n  error: Error | null;\n  /** Total count of submissions (from last fetch) */\n  total: number;\n  /** Whether there are more submissions to load */\n  hasMore: boolean;\n  /** Fetch submissions for a form */\n  fetchSubmissions: (formId: string, params?: FormSubmissionListParams) => Promise<PaginatedResponse<FormSubmission>>;\n  /** Submit a form response */\n  submitForm: (formId: string, data: Record<string, unknown>) => Promise<FormSubmission>;\n  /** Reset error state */\n  clearError: () => void;\n}\n\n/**\n * Hook for managing form submissions.\n *\n * @example\n * ```tsx\n * function ContactForm({ formId }) {\n *   const { submitForm, isSubmitting, error } = useFormSubmissions();\n *   const [formData, setFormData] = useState({});\n *\n *   const handleSubmit = async (e) => {\n *     e.preventDefault();\n *     try {\n *       await submitForm(formId, formData);\n *       alert('Form submitted successfully!');\n *     } catch (err) {\n *       // Error is also available in the error state\n *     }\n *   };\n *\n *   return (\n *     <form onSubmit={handleSubmit}>\n *       {error && <div className=\"error\">{error.message}</div>}\n *       <button type=\"submit\" disabled={isSubmitting}>\n *         {isSubmitting ? 'Submitting...' : 'Submit'}\n *       </button>\n *     </form>\n *   );\n * }\n * ```\n */\nexport function useFormSubmissions(): UseFormSubmissionsResult {\n  const client = useL4yercak3Client();\n  const [submissions, setSubmissions] = useState<FormSubmission[]>([]);\n  const [loading, setLoading] = useState(false);\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n  const [total, setTotal] = useState(0);\n  const [hasMore, setHasMore] = useState(false);\n\n  const fetchSubmissions = useCallback(\n    async (formId: string, params?: FormSubmissionListParams): Promise<PaginatedResponse<FormSubmission>> => {\n      setLoading(true);\n      setError(null);\n      try {\n        const result = await client.forms.getSubmissions(formId, params);\n        setSubmissions(result.items);\n        setTotal(result.total);\n        setHasMore(result.hasMore);\n        return result;\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const submitForm = useCallback(\n    async (formId: string, data: Record<string, unknown>): Promise<FormSubmission> => {\n      setIsSubmitting(true);\n      setError(null);\n      try {\n        const submission = await client.forms.submit(formId, data);\n        setSubmissions((prev) => [submission, ...prev]);\n        setTotal((prev) => prev + 1);\n        return submission;\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setIsSubmitting(false);\n      }\n    },\n    [client]\n  );\n\n  const clearError = useCallback(() => {\n    setError(null);\n  }, []);\n\n  return {\n    submissions,\n    loading,\n    isSubmitting,\n    error,\n    total,\n    hasMore,\n    fetchSubmissions,\n    submitForm,\n    clearError,\n  };\n}\n","'use client';\n\nimport { useState, useCallback } from 'react';\nimport { useL4yercak3Client } from '../provider';\nimport type {\n  Product,\n  ProductListParams,\n  CheckoutSession,\n  CheckoutSessionCreateInput,\n  PaginatedResponse,\n} from '../../types';\n\nexport interface UseProductsResult {\n  /** Current list of products */\n  products: Product[];\n  /** Whether a request is in progress */\n  loading: boolean;\n  /** Last error that occurred */\n  error: Error | null;\n  /** Total count of products (from last fetch) */\n  total: number;\n  /** Whether there are more products to load */\n  hasMore: boolean;\n  /** Fetch products with optional filters */\n  fetchProducts: (params?: ProductListParams) => Promise<PaginatedResponse<Product>>;\n  /** Get a single product by ID */\n  getProduct: (id: string) => Promise<Product>;\n  /** Reset error state */\n  clearError: () => void;\n}\n\n/**\n * Hook for fetching products.\n *\n * @example\n * ```tsx\n * function ProductCatalog({ eventId }) {\n *   const { products, loading, fetchProducts } = useProducts();\n *\n *   useEffect(() => {\n *     fetchProducts({ eventId, status: 'active' });\n *   }, [eventId]);\n *\n *   return (\n *     <div className=\"grid grid-cols-3 gap-4\">\n *       {products.map(product => (\n *         <ProductCard key={product.id} product={product} />\n *       ))}\n *     </div>\n *   );\n * }\n * ```\n */\nexport function useProducts(): UseProductsResult {\n  const client = useL4yercak3Client();\n  const [products, setProducts] = useState<Product[]>([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n  const [total, setTotal] = useState(0);\n  const [hasMore, setHasMore] = useState(false);\n\n  const fetchProducts = useCallback(\n    async (params?: ProductListParams): Promise<PaginatedResponse<Product>> => {\n      setLoading(true);\n      setError(null);\n      try {\n        const result = await client.products.list(params);\n        setProducts(result.items);\n        setTotal(result.total);\n        setHasMore(result.hasMore);\n        return result;\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const getProduct = useCallback(\n    async (id: string): Promise<Product> => {\n      setLoading(true);\n      setError(null);\n      try {\n        return await client.products.get(id);\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const clearError = useCallback(() => {\n    setError(null);\n  }, []);\n\n  return {\n    products,\n    loading,\n    error,\n    total,\n    hasMore,\n    fetchProducts,\n    getProduct,\n    clearError,\n  };\n}\n\nexport interface CartItem {\n  productId: string;\n  quantity: number;\n  product?: Product;\n}\n\nexport interface UseCheckoutResult {\n  /** Current cart items */\n  cart: CartItem[];\n  /** Whether a checkout is being created */\n  isCreatingCheckout: boolean;\n  /** Last error that occurred */\n  error: Error | null;\n  /** Current checkout session (if created) */\n  checkoutSession: CheckoutSession | null;\n  /** Add an item to the cart */\n  addToCart: (productId: string, quantity?: number) => void;\n  /** Remove an item from the cart */\n  removeFromCart: (productId: string) => void;\n  /** Update quantity of an item */\n  updateQuantity: (productId: string, quantity: number) => void;\n  /** Clear the cart */\n  clearCart: () => void;\n  /** Create a checkout session and redirect to payment */\n  createCheckoutSession: (options: Omit<CheckoutSessionCreateInput, 'items'>) => Promise<CheckoutSession>;\n  /** Get an existing checkout session by ID */\n  getCheckoutSession: (sessionId: string) => Promise<CheckoutSession>;\n  /** Reset error state */\n  clearError: () => void;\n}\n\n/**\n * Hook for managing shopping cart and checkout.\n *\n * @example\n * ```tsx\n * function ProductCard({ product }) {\n *   const { addToCart } = useCheckout();\n *\n *   return (\n *     <div>\n *       <h3>{product.name}</h3>\n *       <p>${(product.priceInCents / 100).toFixed(2)}</p>\n *       <button onClick={() => addToCart(product.id)}>\n *         Add to Cart\n *       </button>\n *     </div>\n *   );\n * }\n *\n * function CartSummary() {\n *   const { cart, createCheckoutSession, isCreatingCheckout } = useCheckout();\n *\n *   const handleCheckout = async () => {\n *     const session = await createCheckoutSession({\n *       successUrl: '/checkout/success',\n *       cancelUrl: '/checkout/cancelled',\n *     });\n *     // Redirect to Stripe checkout\n *     window.location.href = session.checkoutUrl;\n *   };\n *\n *   return (\n *     <div>\n *       <p>{cart.length} items in cart</p>\n *       <button onClick={handleCheckout} disabled={isCreatingCheckout || cart.length === 0}>\n *         {isCreatingCheckout ? 'Creating checkout...' : 'Proceed to Checkout'}\n *       </button>\n *     </div>\n *   );\n * }\n * ```\n */\nexport function useCheckout(): UseCheckoutResult {\n  const client = useL4yercak3Client();\n  const [cart, setCart] = useState<CartItem[]>([]);\n  const [isCreatingCheckout, setIsCreatingCheckout] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n  const [checkoutSession, setCheckoutSession] = useState<CheckoutSession | null>(null);\n\n  const addToCart = useCallback((productId: string, quantity: number = 1) => {\n    setCart((prev) => {\n      const existing = prev.find((item) => item.productId === productId);\n      if (existing) {\n        return prev.map((item) =>\n          item.productId === productId\n            ? { ...item, quantity: item.quantity + quantity }\n            : item\n        );\n      }\n      return [...prev, { productId, quantity }];\n    });\n  }, []);\n\n  const removeFromCart = useCallback((productId: string) => {\n    setCart((prev) => prev.filter((item) => item.productId !== productId));\n  }, []);\n\n  const updateQuantity = useCallback((productId: string, quantity: number) => {\n    if (quantity <= 0) {\n      setCart((prev) => prev.filter((item) => item.productId !== productId));\n    } else {\n      setCart((prev) =>\n        prev.map((item) =>\n          item.productId === productId ? { ...item, quantity } : item\n        )\n      );\n    }\n  }, []);\n\n  const clearCart = useCallback(() => {\n    setCart([]);\n  }, []);\n\n  const createCheckoutSession = useCallback(\n    async (options: Omit<CheckoutSessionCreateInput, 'items'>): Promise<CheckoutSession> => {\n      if (cart.length === 0) {\n        throw new Error('Cart is empty');\n      }\n\n      setIsCreatingCheckout(true);\n      setError(null);\n      try {\n        const session = await client.checkout.createSession({\n          ...options,\n          items: cart.map((item) => ({\n            productId: item.productId,\n            quantity: item.quantity,\n          })),\n        });\n        setCheckoutSession(session);\n        return session;\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setIsCreatingCheckout(false);\n      }\n    },\n    [client, cart]\n  );\n\n  const getCheckoutSession = useCallback(\n    async (sessionId: string): Promise<CheckoutSession> => {\n      setError(null);\n      try {\n        const session = await client.checkout.getSession(sessionId);\n        setCheckoutSession(session);\n        return session;\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      }\n    },\n    [client]\n  );\n\n  const clearError = useCallback(() => {\n    setError(null);\n  }, []);\n\n  return {\n    cart,\n    isCreatingCheckout,\n    error,\n    checkoutSession,\n    addToCart,\n    removeFromCart,\n    updateQuantity,\n    clearCart,\n    createCheckoutSession,\n    getCheckoutSession,\n    clearError,\n  };\n}\n","'use client';\n\nimport { useState, useCallback } from 'react';\nimport { useL4yercak3Client } from '../provider';\nimport type { Order, OrderListParams, PaginatedResponse } from '../../types';\n\nexport interface UseOrdersResult {\n  /** Current list of orders */\n  orders: Order[];\n  /** Whether a request is in progress */\n  loading: boolean;\n  /** Last error that occurred */\n  error: Error | null;\n  /** Total count of orders (from last fetch) */\n  total: number;\n  /** Whether there are more orders to load */\n  hasMore: boolean;\n  /** Fetch orders with optional filters */\n  fetchOrders: (params?: OrderListParams) => Promise<PaginatedResponse<Order>>;\n  /** Get a single order by ID */\n  getOrder: (id: string) => Promise<Order>;\n  /** Get an order by order number */\n  getOrderByNumber: (orderNumber: string) => Promise<Order>;\n  /** Reset error state */\n  clearError: () => void;\n}\n\n/**\n * Hook for managing orders.\n *\n * @example\n * ```tsx\n * function OrderHistory({ contactId }) {\n *   const { orders, loading, fetchOrders } = useOrders();\n *\n *   useEffect(() => {\n *     fetchOrders({ contactId, status: 'paid' });\n *   }, [contactId]);\n *\n *   return (\n *     <div>\n *       {orders.map(order => (\n *         <OrderCard key={order.id} order={order} />\n *       ))}\n *     </div>\n *   );\n * }\n * ```\n */\nexport function useOrders(): UseOrdersResult {\n  const client = useL4yercak3Client();\n  const [orders, setOrders] = useState<Order[]>([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n  const [total, setTotal] = useState(0);\n  const [hasMore, setHasMore] = useState(false);\n\n  const fetchOrders = useCallback(\n    async (params?: OrderListParams): Promise<PaginatedResponse<Order>> => {\n      setLoading(true);\n      setError(null);\n      try {\n        const result = await client.orders.list(params);\n        setOrders(result.items);\n        setTotal(result.total);\n        setHasMore(result.hasMore);\n        return result;\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const getOrder = useCallback(\n    async (id: string): Promise<Order> => {\n      setLoading(true);\n      setError(null);\n      try {\n        return await client.orders.get(id);\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const getOrderByNumber = useCallback(\n    async (orderNumber: string): Promise<Order> => {\n      setLoading(true);\n      setError(null);\n      try {\n        return await client.orders.getByOrderNumber(orderNumber);\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const clearError = useCallback(() => {\n    setError(null);\n  }, []);\n\n  return {\n    orders,\n    loading,\n    error,\n    total,\n    hasMore,\n    fetchOrders,\n    getOrder,\n    getOrderByNumber,\n    clearError,\n  };\n}\n","'use client';\n\nimport { useState, useCallback } from 'react';\nimport { useL4yercak3Client } from '../provider';\nimport type { Invoice, InvoiceCreateInput, InvoiceListParams, PaginatedResponse } from '../../types';\n\nexport interface UseInvoicesResult {\n  /** Current list of invoices */\n  invoices: Invoice[];\n  /** Whether a request is in progress */\n  loading: boolean;\n  /** Last error that occurred */\n  error: Error | null;\n  /** Total count of invoices (from last fetch) */\n  total: number;\n  /** Whether there are more invoices to load */\n  hasMore: boolean;\n  /** Fetch invoices with optional filters */\n  fetchInvoices: (params?: InvoiceListParams) => Promise<PaginatedResponse<Invoice>>;\n  /** Get a single invoice by ID */\n  getInvoice: (id: string) => Promise<Invoice>;\n  /** Create a new invoice */\n  createInvoice: (data: InvoiceCreateInput) => Promise<Invoice>;\n  /** Send an invoice */\n  sendInvoice: (id: string, options?: { emailTo?: string; message?: string }) => Promise<void>;\n  /** Mark an invoice as paid */\n  markPaid: (id: string, data?: { paidAt?: string; paymentMethod?: string; paymentReference?: string }) => Promise<Invoice>;\n  /** Get the PDF URL for an invoice */\n  getPdf: (id: string) => Promise<{ pdfUrl: string }>;\n  /** Void an invoice */\n  voidInvoice: (id: string) => Promise<Invoice>;\n  /** Reset error state */\n  clearError: () => void;\n}\n\n/**\n * Hook for managing invoices.\n *\n * @example\n * ```tsx\n * function InvoiceList({ organizationId }) {\n *   const { invoices, loading, fetchInvoices, sendInvoice } = useInvoices();\n *\n *   useEffect(() => {\n *     fetchInvoices({ organizationId, status: 'sent' });\n *   }, [organizationId]);\n *\n *   return (\n *     <table>\n *       <tbody>\n *         {invoices.map(invoice => (\n *           <tr key={invoice.id}>\n *             <td>{invoice.number}</td>\n *             <td>${(invoice.totalInCents / 100).toFixed(2)}</td>\n *             <td>{invoice.status}</td>\n *           </tr>\n *         ))}\n *       </tbody>\n *     </table>\n *   );\n * }\n * ```\n */\nexport function useInvoices(): UseInvoicesResult {\n  const client = useL4yercak3Client();\n  const [invoices, setInvoices] = useState<Invoice[]>([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n  const [total, setTotal] = useState(0);\n  const [hasMore, setHasMore] = useState(false);\n\n  const fetchInvoices = useCallback(\n    async (params?: InvoiceListParams): Promise<PaginatedResponse<Invoice>> => {\n      setLoading(true);\n      setError(null);\n      try {\n        const result = await client.invoices.list(params);\n        setInvoices(result.items);\n        setTotal(result.total);\n        setHasMore(result.hasMore);\n        return result;\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const getInvoice = useCallback(\n    async (id: string): Promise<Invoice> => {\n      setLoading(true);\n      setError(null);\n      try {\n        return await client.invoices.get(id);\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const createInvoice = useCallback(\n    async (data: InvoiceCreateInput): Promise<Invoice> => {\n      setLoading(true);\n      setError(null);\n      try {\n        const invoice = await client.invoices.create(data);\n        setInvoices((prev) => [...prev, invoice]);\n        setTotal((prev) => prev + 1);\n        return invoice;\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const sendInvoice = useCallback(\n    async (id: string, options?: { emailTo?: string; message?: string }): Promise<void> => {\n      setLoading(true);\n      setError(null);\n      try {\n        await client.invoices.send(id, options);\n        setInvoices((prev) =>\n          prev.map((inv) => (inv.id === id ? { ...inv, status: 'sent' as const } : inv))\n        );\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const markPaid = useCallback(\n    async (\n      id: string,\n      data?: { paidAt?: string; paymentMethod?: string; paymentReference?: string }\n    ): Promise<Invoice> => {\n      setLoading(true);\n      setError(null);\n      try {\n        const updated = await client.invoices.markPaid(id, data);\n        setInvoices((prev) => prev.map((inv) => (inv.id === id ? updated : inv)));\n        return updated;\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const getPdf = useCallback(\n    async (id: string): Promise<{ pdfUrl: string }> => {\n      setError(null);\n      try {\n        return await client.invoices.getPdf(id);\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      }\n    },\n    [client]\n  );\n\n  const voidInvoice = useCallback(\n    async (id: string): Promise<Invoice> => {\n      setLoading(true);\n      setError(null);\n      try {\n        const updated = await client.invoices.void(id);\n        setInvoices((prev) => prev.map((inv) => (inv.id === id ? updated : inv)));\n        return updated;\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const clearError = useCallback(() => {\n    setError(null);\n  }, []);\n\n  return {\n    invoices,\n    loading,\n    error,\n    total,\n    hasMore,\n    fetchInvoices,\n    getInvoice,\n    createInvoice,\n    sendInvoice,\n    markPaid,\n    getPdf,\n    voidInvoice,\n    clearError,\n  };\n}\n","'use client';\n\nimport { useState, useCallback } from 'react';\nimport { useL4yercak3Client } from '../provider';\nimport type {\n  BenefitClaim,\n  BenefitClaimInput,\n  BenefitClaimListParams,\n  CommissionPayout,\n  CommissionPayoutListParams,\n  PaginatedResponse,\n} from '../../types';\n\nexport interface UseBenefitClaimsResult {\n  /** Current list of benefit claims */\n  claims: BenefitClaim[];\n  /** Whether a request is in progress */\n  loading: boolean;\n  /** Last error that occurred */\n  error: Error | null;\n  /** Total count of claims (from last fetch) */\n  total: number;\n  /** Whether there are more claims to load */\n  hasMore: boolean;\n  /** Fetch claims with optional filters */\n  fetchClaims: (params?: BenefitClaimListParams) => Promise<PaginatedResponse<BenefitClaim>>;\n  /** Get a single claim by ID */\n  getClaim: (id: string) => Promise<BenefitClaim>;\n  /** Create a new benefit claim */\n  createClaim: (data: BenefitClaimInput) => Promise<BenefitClaim>;\n  /** Approve a benefit claim */\n  approveClaim: (id: string, notes?: string) => Promise<BenefitClaim>;\n  /** Reject a benefit claim */\n  rejectClaim: (id: string, reason: string) => Promise<BenefitClaim>;\n  /** Reset error state */\n  clearError: () => void;\n}\n\n/**\n * Hook for managing benefit claims.\n *\n * @example\n * ```tsx\n * function ClaimsList({ memberId }) {\n *   const { claims, loading, fetchClaims } = useBenefitClaims();\n *\n *   useEffect(() => {\n *     fetchClaims({ memberId, status: 'pending' });\n *   }, [memberId]);\n *\n *   return (\n *     <ul>\n *       {claims.map(claim => (\n *         <li key={claim.id}>\n *           {claim.benefitType} - ${(claim.amountInCents / 100).toFixed(2)}\n *         </li>\n *       ))}\n *     </ul>\n *   );\n * }\n * ```\n */\nexport function useBenefitClaims(): UseBenefitClaimsResult {\n  const client = useL4yercak3Client();\n  const [claims, setClaims] = useState<BenefitClaim[]>([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n  const [total, setTotal] = useState(0);\n  const [hasMore, setHasMore] = useState(false);\n\n  const fetchClaims = useCallback(\n    async (params?: BenefitClaimListParams): Promise<PaginatedResponse<BenefitClaim>> => {\n      setLoading(true);\n      setError(null);\n      try {\n        const result = await client.benefits.listClaims(params);\n        setClaims(result.items);\n        setTotal(result.total);\n        setHasMore(result.hasMore);\n        return result;\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const getClaim = useCallback(\n    async (id: string): Promise<BenefitClaim> => {\n      setLoading(true);\n      setError(null);\n      try {\n        return await client.benefits.getClaim(id);\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const createClaim = useCallback(\n    async (data: BenefitClaimInput): Promise<BenefitClaim> => {\n      setLoading(true);\n      setError(null);\n      try {\n        const claim = await client.benefits.createClaim(data);\n        setClaims((prev) => [claim, ...prev]);\n        setTotal((prev) => prev + 1);\n        return claim;\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const approveClaim = useCallback(\n    async (id: string, notes?: string): Promise<BenefitClaim> => {\n      setLoading(true);\n      setError(null);\n      try {\n        const updated = await client.benefits.approveClaim(id, notes);\n        setClaims((prev) => prev.map((c) => (c.id === id ? updated : c)));\n        return updated;\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const rejectClaim = useCallback(\n    async (id: string, reason: string): Promise<BenefitClaim> => {\n      setLoading(true);\n      setError(null);\n      try {\n        const updated = await client.benefits.rejectClaim(id, reason);\n        setClaims((prev) => prev.map((c) => (c.id === id ? updated : c)));\n        return updated;\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const clearError = useCallback(() => {\n    setError(null);\n  }, []);\n\n  return {\n    claims,\n    loading,\n    error,\n    total,\n    hasMore,\n    fetchClaims,\n    getClaim,\n    createClaim,\n    approveClaim,\n    rejectClaim,\n    clearError,\n  };\n}\n\nexport interface UseCommissionsResult {\n  /** Current list of commission payouts */\n  commissions: CommissionPayout[];\n  /** Whether a request is in progress */\n  loading: boolean;\n  /** Last error that occurred */\n  error: Error | null;\n  /** Total count of commissions (from last fetch) */\n  total: number;\n  /** Whether there are more commissions to load */\n  hasMore: boolean;\n  /** Fetch commissions with optional filters */\n  fetchCommissions: (params?: CommissionPayoutListParams) => Promise<PaginatedResponse<CommissionPayout>>;\n  /** Get a single commission payout by ID */\n  getCommission: (id: string) => Promise<CommissionPayout>;\n  /** Reset error state */\n  clearError: () => void;\n}\n\n/**\n * Hook for viewing commission payouts.\n *\n * @example\n * ```tsx\n * function CommissionHistory({ memberId }) {\n *   const { commissions, loading, fetchCommissions } = useCommissions();\n *\n *   useEffect(() => {\n *     fetchCommissions({ memberId, status: 'completed' });\n *   }, [memberId]);\n *\n *   return (\n *     <ul>\n *       {commissions.map(commission => (\n *         <li key={commission.id}>\n *           {commission.commissionType} - ${(commission.amountInCents / 100).toFixed(2)}\n *         </li>\n *       ))}\n *     </ul>\n *   );\n * }\n * ```\n */\nexport function useCommissions(): UseCommissionsResult {\n  const client = useL4yercak3Client();\n  const [commissions, setCommissions] = useState<CommissionPayout[]>([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n  const [total, setTotal] = useState(0);\n  const [hasMore, setHasMore] = useState(false);\n\n  const fetchCommissions = useCallback(\n    async (params?: CommissionPayoutListParams): Promise<PaginatedResponse<CommissionPayout>> => {\n      setLoading(true);\n      setError(null);\n      try {\n        const result = await client.benefits.listCommissions(params);\n        setCommissions(result.items);\n        setTotal(result.total);\n        setHasMore(result.hasMore);\n        return result;\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const getCommission = useCallback(\n    async (id: string): Promise<CommissionPayout> => {\n      setLoading(true);\n      setError(null);\n      try {\n        return await client.benefits.getCommission(id);\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const clearError = useCallback(() => {\n    setError(null);\n  }, []);\n\n  return {\n    commissions,\n    loading,\n    error,\n    total,\n    hasMore,\n    fetchCommissions,\n    getCommission,\n    clearError,\n  };\n}\n","'use client';\n\nimport { useState, useCallback } from 'react';\nimport { useL4yercak3Client } from '../provider';\nimport type { Certificate, PaginatedResponse } from '../../types';\n\nexport interface UseCertificatesResult {\n  /** Current list of certificates */\n  certificates: Certificate[];\n  /** Whether a request is in progress */\n  loading: boolean;\n  /** Last error that occurred */\n  error: Error | null;\n  /** Total count of certificates (from last fetch) */\n  total: number;\n  /** Whether there are more certificates to load */\n  hasMore: boolean;\n  /** Fetch certificates with optional filters */\n  fetchCertificates: (params?: { recipientId?: string; eventId?: string; limit?: number }) => Promise<PaginatedResponse<Certificate>>;\n  /** Get a single certificate by ID */\n  getCertificate: (id: string) => Promise<Certificate>;\n  /** Verify a certificate by certificate number */\n  verifyCertificate: (certificateNumber: string) => Promise<Certificate>;\n  /** Reset error state */\n  clearError: () => void;\n}\n\n/**\n * Hook for managing certificates.\n *\n * @example\n * ```tsx\n * function CertificateList({ recipientId }) {\n *   const { certificates, loading, fetchCertificates } = useCertificates();\n *\n *   useEffect(() => {\n *     fetchCertificates({ recipientId });\n *   }, [recipientId]);\n *\n *   return (\n *     <div className=\"grid gap-4\">\n *       {certificates.map(cert => (\n *         <CertificateCard key={cert.id} certificate={cert} />\n *       ))}\n *     </div>\n *   );\n * }\n * ```\n */\nexport function useCertificates(): UseCertificatesResult {\n  const client = useL4yercak3Client();\n  const [certificates, setCertificates] = useState<Certificate[]>([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n  const [total, setTotal] = useState(0);\n  const [hasMore, setHasMore] = useState(false);\n\n  const fetchCertificates = useCallback(\n    async (params?: { recipientId?: string; eventId?: string; limit?: number }): Promise<PaginatedResponse<Certificate>> => {\n      setLoading(true);\n      setError(null);\n      try {\n        const result = await client.certificates.list(params);\n        setCertificates(result.items);\n        setTotal(result.total);\n        setHasMore(result.hasMore);\n        return result;\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const getCertificate = useCallback(\n    async (id: string): Promise<Certificate> => {\n      setLoading(true);\n      setError(null);\n      try {\n        return await client.certificates.get(id);\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const verifyCertificate = useCallback(\n    async (certificateNumber: string): Promise<Certificate> => {\n      setLoading(true);\n      setError(null);\n      try {\n        return await client.certificates.verify(certificateNumber);\n      } catch (e) {\n        const err = e instanceof Error ? e : new Error(String(e));\n        setError(err);\n        throw err;\n      } finally {\n        setLoading(false);\n      }\n    },\n    [client]\n  );\n\n  const clearError = useCallback(() => {\n    setError(null);\n  }, []);\n\n  return {\n    certificates,\n    loading,\n    error,\n    total,\n    hasMore,\n    fetchCertificates,\n    getCertificate,\n    verifyCertificate,\n    clearError,\n  };\n}\n"],"mappings":"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","names":["import_react","import_react","import_react","import_react","import_react","import_react","import_react","import_react","import_react"]}