/**
 * AGENT CONFIG DETECTOR
 *
 * Detects agent-config.json in builder files and prepares it for the connect step.
 * Unlike v0-file-analyzer.ts which scans TSX for UI patterns, this scans for
 * the specific JSON config file generated by setup mode.
 */

import type { SectionConnection, DetectedItem } from "@/contexts/builder-context";

export interface AgentConfigJson {
  name: string;
  subtype?: string;
  displayName?: string;
  personality?: string;
  language?: string;
  additionalLanguages?: string[];
  brandVoiceInstructions?: string;
  systemPrompt?: string;
  faqEntries?: Array<{ q: string; a: string }>;
  knowledgeBaseTags?: string[];
  enabledTools?: string[];
  disabledTools?: string[];
  autonomyLevel?: "supervised" | "autonomous" | "draft_only";
  maxMessagesPerDay?: number;
  maxCostPerDay?: number;
  requireApprovalFor?: string[];
  blockedTopics?: string[];
  modelProvider?: string;
  modelId?: string;
  temperature?: number;
  maxTokens?: number;
  channelBindings?: Array<{ channel: string; enabled: boolean }>;
}

export interface AgentDetectionResult {
  section: SectionConnection | null;
  config: AgentConfigJson | null;
  kbFiles: Array<{ path: string; content: string }>;
}

/**
 * Scan builder files for agent-config.json and kb/*.md knowledge base docs.
 * Returns a SectionConnection for the connect panel + parsed config + KB files.
 */
export function detectAgentConfig(
  files: Array<{ path: string; content: string }>
): AgentDetectionResult {
  const configFile = files.find(
    (f) => f.path === "agent-config.json" || f.path.endsWith("/agent-config.json")
  );

  if (!configFile) {
    return { section: null, config: null, kbFiles: [] };
  }

  let config: AgentConfigJson;
  try {
    config = JSON.parse(configFile.content) as AgentConfigJson;
  } catch {
    return { section: null, config: null, kbFiles: [] };
  }

  // Require at minimum a name
  if (!config.name || typeof config.name !== "string") {
    return { section: null, config: null, kbFiles: [] };
  }

  // Collect kb/*.md files
  const kbFiles = files.filter(
    (f) =>
      (f.path.startsWith("kb/") || f.path.includes("/kb/")) &&
      f.path.endsWith(".md")
  );

  const enabledChannels = (config.channelBindings || [])
    .filter((b) => b.enabled)
    .map((b) => b.channel);

  const detectedItem: DetectedItem = {
    id: "agent_config_0",
    type: "agent",
    placeholderData: {
      name: config.displayName || config.name,
      description: `${config.subtype || "general"} agent · ${kbFiles.length} KB docs${enabledChannels.length > 0 ? ` · ${enabledChannels.join(", ")}` : ""}`,
    },
    existingMatches: [],
    connectionChoice: null,
    linkedRecordId: null,
    createdRecordId: null,
  };

  const section: SectionConnection = {
    sectionId: "setup:agent",
    sectionType: "agent",
    sectionLabel: `AI Agent: ${config.displayName || config.name}`,
    detectedItems: [detectedItem],
    connectionStatus: "pending",
  };

  return { section, config, kbFiles };
}

/**
 * Validate channel bindings against org's configured providers.
 * Returns which channels are ready vs need configuration.
 */
export function validateChannelBindings(
  bindings: Array<{ channel: string; enabled: boolean }>,
  configuredChannels: string[]
): { ready: string[]; needsConfig: string[] } {
  const configuredSet = new Set(configuredChannels);
  const ready: string[] = [];
  const needsConfig: string[] = [];

  for (const binding of bindings) {
    if (!binding.enabled) continue;
    if (configuredSet.has(binding.channel)) {
      ready.push(binding.channel);
    } else {
      // webchat doesn't need external provider configuration
      if (binding.channel === "webchat") {
        ready.push(binding.channel);
      } else {
        needsConfig.push(binding.channel);
      }
    }
  }

  return { ready, needsConfig };
}
