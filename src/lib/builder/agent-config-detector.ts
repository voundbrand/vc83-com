/**
 * AGENT CONFIG DETECTOR
 *
 * Detects agent-config.json in builder files and prepares it for the connect step.
 * Unlike v0-file-analyzer.ts which scans TSX for UI patterns, this scans for
 * the specific JSON config file generated by setup mode.
 */

import type { SectionConnection, DetectedItem } from "@/contexts/builder-context";

export interface AgentConfigJson {
  name: string;
  subtype?: string;
  displayName?: string;
  personality?: string;
  language?: string;
  additionalLanguages?: string[];
  brandVoiceInstructions?: string;
  systemPrompt?: string;
  faqEntries?: Array<{ q: string; a: string }>;
  knowledgeBaseTags?: string[];
  enabledTools?: string[];
  disabledTools?: string[];
  autonomyLevel?: "supervised" | "autonomous" | "draft_only";
  maxMessagesPerDay?: number;
  maxCostPerDay?: number;
  requireApprovalFor?: string[];
  blockedTopics?: string[];
  modelProvider?: string;
  modelId?: string;
  temperature?: number;
  maxTokens?: number;
  channelBindings?: Array<{ channel: string; enabled: boolean }>;
}

export interface AgentDetectionResult {
  section: SectionConnection | null;
  config: AgentConfigJson | null;
  kbFiles: Array<{ path: string; content: string }>;
  detectedArtifacts: string[];
  validationErrors: string[];
  warnings: string[];
}

function normalizePath(path: string): string {
  return path.trim().replace(/^\.?\//, "");
}

/**
 * Scan builder files for agent-config.json and kb/*.md knowledge base docs.
 * Returns a SectionConnection for the connect panel + parsed config + KB files.
 */
export function detectAgentConfig(
  files: Array<{ path: string; content: string }>
): AgentDetectionResult {
  const normalizedFiles = files.map((file) => ({
    ...file,
    path: normalizePath(file.path),
  }));
  const detectedArtifacts = normalizedFiles
    .map((file) => file.path)
    .sort((a, b) => a.localeCompare(b));
  const validationErrors: string[] = [];
  const warnings: string[] = [];

  const kbFiles = normalizedFiles.filter(
    (file) =>
      (file.path.startsWith("kb/") || file.path.includes("/kb/")) &&
      file.path.endsWith(".md")
  );

  const configFile = normalizedFiles.find(
    (file) => file.path === "agent-config.json" || file.path.endsWith("/agent-config.json")
  );

  if (!configFile) {
    if (kbFiles.length > 0) {
      validationErrors.push(
        "Found `kb/*.md` documents but `agent-config.json` is missing."
      );
    }
    return {
      section: null,
      config: null,
      kbFiles,
      detectedArtifacts,
      validationErrors,
      warnings,
    };
  }

  let config: AgentConfigJson;
  try {
    config = JSON.parse(configFile.content) as AgentConfigJson;
  } catch {
    validationErrors.push("`agent-config.json` is not valid JSON.");
    return {
      section: null,
      config: null,
      kbFiles,
      detectedArtifacts,
      validationErrors,
      warnings,
    };
  }

  // Require at minimum a name
  if (!config.name || typeof config.name !== "string") {
    validationErrors.push("`agent-config.json` must include a non-empty `name` field.");
    return {
      section: null,
      config: null,
      kbFiles,
      detectedArtifacts,
      validationErrors,
      warnings,
    };
  }

  if (kbFiles.length === 0) {
    warnings.push(
      "No `kb/*.md` files were found; connect can still create the agent, but knowledge import will be skipped."
    );
  }

  const enabledChannels = (config.channelBindings || [])
    .filter((b) => b.enabled)
    .map((b) => b.channel);

  const detectedItem: DetectedItem = {
    id: "agent_config_0",
    type: "agent",
    placeholderData: {
      name: config.displayName || config.name,
      description: `${config.subtype || "general"} agent · ${kbFiles.length} KB docs${enabledChannels.length > 0 ? ` · ${enabledChannels.join(", ")}` : ""}`,
    },
    existingMatches: [],
    connectionChoice: "create",
    linkedRecordId: null,
    createdRecordId: null,
  };

  const section: SectionConnection = {
    sectionId: "setup:agent",
    sectionType: "agent",
    sectionLabel: `AI Agent: ${config.displayName || config.name}`,
    detectedItems: [detectedItem],
    connectionStatus: "pending",
  };

  return {
    section,
    config,
    kbFiles,
    detectedArtifacts,
    validationErrors,
    warnings,
  };
}

/**
 * Validate channel bindings against org's configured providers.
 * Returns which channels are ready vs need configuration.
 */
export function validateChannelBindings(
  bindings: Array<{ channel: string; enabled: boolean }>,
  configuredChannels: string[]
): { ready: string[]; needsConfig: string[] } {
  const configuredSet = new Set(configuredChannels);
  const ready: string[] = [];
  const needsConfig: string[] = [];

  for (const binding of bindings) {
    if (!binding.enabled) continue;
    if (configuredSet.has(binding.channel)) {
      ready.push(binding.channel);
    } else {
      // webchat doesn't need external provider configuration
      if (binding.channel === "webchat") {
        ready.push(binding.channel);
      } else {
        needsConfig.push(binding.channel);
      }
    }
  }

  return { ready, needsConfig };
}
