/**
 * INVOICE PAYMENT PROVIDER
 *
 * Payment provider for B2B invoicing - creates invoices instead of immediate payment.
 *
 * ARCHITECTURE:
 * - initiateInvoicePayment: Validates invoice payment is allowed, returns invoice reference
 * - Frontend calls completeCheckoutAndFulfill with inv_... paymentIntentId
 * - completeCheckoutAndFulfill handles: tickets, CRM, transactions, invoice PDF, emails
 *
 * This ensures consistent behavior with Stripe flow and avoids code duplication.
 */

import { action } from "../_generated/server";
import { v } from "convex/values";
import { internal } from "../_generated/api";
import type { Id, Doc } from "../_generated/dataModel";
import type {
  IPaymentProvider,
  ConnectionParams,
  ConnectionResult,
  AccountStatus,
  CheckoutSessionParams,
  CheckoutSessionResult,
  PaymentVerificationResult,
  InvoiceParams,
  InvoiceResult,
  InvoiceSendResult,
  WebhookHandlingResult,
} from "./types";

export interface InvoicePaymentConfig {
  type: "invoice";
  name: string;
  description: string;
  requiresSetup: boolean;
  supportsB2B: boolean;
  supportsB2C: boolean;
}

export const invoicePaymentProvider: InvoicePaymentConfig = {
  type: "invoice",
  name: "Invoice (Pay Later)",
  description: "An invoice will be sent for payment",
  requiresSetup: false,
  supportsB2B: true,
  supportsB2C: false, // For now, only B2B invoicing
};

/**
 * INITIATE INVOICE PAYMENT
 *
 * Validates that invoice payment is allowed and returns an invoice reference.
 * The actual work (tickets, CRM, transactions, emails) is done by completeCheckoutAndFulfill.
 *
 * This follows the same pattern as Stripe:
 * 1. Frontend calls initiateInvoicePayment ‚Üí validates and returns reference
 * 2. Frontend calls completeCheckoutAndFulfill with inv_... paymentIntentId
 * 3. completeCheckoutAndFulfill handles everything else
 */
export const initiateInvoicePayment = action({
  args: {
    sessionId: v.string(),
    checkoutSessionId: v.id("objects"),
    organizationId: v.id("organizations"),
  },
  handler: async (ctx, args): Promise<{
    success: boolean;
    requiresUserAction: boolean;
    invoiceId?: string;
    invoiceNumber?: string;
    pdfUrl?: string | null;
    status: string;
    error?: string;
  }> => {
    try {
      console.log("üìã [initiateInvoicePayment] Starting invoice payment validation...");

      // 1. Get checkout session
      const session = await ctx.runQuery(
        internal.checkoutSessionOntology.getCheckoutSessionInternal,
        { checkoutSessionId: args.checkoutSessionId }
      ) as Doc<"objects"> | null;

      if (!session || session.type !== "checkout_session") {
        throw new Error("Checkout session not found");
      }

      // 2. Validate we have products
      const selectedProducts = session.customProperties?.selectedProducts as Array<{ productId: Id<"objects">; quantity: number }> | undefined;

      if (!selectedProducts || selectedProducts.length === 0) {
        console.error("‚ùå [initiateInvoicePayment] No products found!");
        throw new Error("No products in checkout session");
      }

      // 3. Validate customer info for B2B invoice
      const transactionType = session.customProperties?.transactionType as "B2C" | "B2B" | undefined;
      const customerCompanyName = session.customProperties?.companyName as string | undefined;
      const customerEmail = session.customProperties?.customerEmail as string | undefined;

      // For B2B invoicing, we need company name
      if (transactionType === "B2B" && !customerCompanyName) {
        console.warn("‚ö†Ô∏è [initiateInvoicePayment] B2B invoice requested but no company name provided");
      }

      if (!customerEmail) {
        throw new Error("Customer email is required for invoice payment");
      }

      // 4. Generate invoice reference ID
      // This will be passed to completeCheckoutAndFulfill as paymentIntentId
      // The inv_ prefix tells completeCheckoutAndFulfill this is an invoice payment
      const invoiceReference = `inv_${Date.now()}_${args.organizationId.slice(-6)}`;

      console.log("‚úÖ [initiateInvoicePayment] Invoice payment validated:", {
        invoiceReference,
        transactionType,
        customerEmail,
        customerCompanyName,
        productCount: selectedProducts.length,
      });

      // 5. Return success - completeCheckoutAndFulfill will handle the rest
      // The frontend will call completeCheckoutAndFulfill with this invoiceReference as paymentIntentId
      return {
        success: true,
        requiresUserAction: false,
        invoiceId: invoiceReference,
        invoiceNumber: undefined, // Will be generated by completeCheckoutAndFulfill
        pdfUrl: undefined, // Will be generated by completeCheckoutAndFulfill
        status: "pending", // Will change to awaiting_payment after completeCheckoutAndFulfill
      };

    } catch (error) {
      console.error("‚ùå [initiateInvoicePayment] Invoice payment initiation failed:", error);
      return {
        success: false,
        requiresUserAction: false,
        status: "error",
        error: error instanceof Error ? error.message : "Unknown error",
      };
    }
  },
});

// =========================================
// INVOICE PROVIDER CLASS (IPaymentProvider Implementation)
// =========================================

/**
 * Invoice Payment Provider
 *
 * Implements IPaymentProvider interface for B2B invoicing.
 * Does not require account connection or immediate payment.
 *
 * Note: Most of the actual invoice handling is done by:
 * - initiateInvoicePayment (validation)
 * - completeCheckoutAndFulfill (tickets, CRM, transactions, invoice PDF, emails)
 *
 * This class provides the interface compliance for the PaymentProviderManager.
 */
export class InvoicePaymentProvider implements IPaymentProvider {
  readonly providerCode = "invoice";
  readonly providerName = "Invoice (Pay Later)";
  readonly providerIcon = "üìã";

  async startAccountConnection(params: ConnectionParams): Promise<ConnectionResult> {
    // Invoice payment doesn't require account connection
    return {
      accountId: "invoice_provider",
      status: "active",
      requiresOnboarding: false,
      metadata: {
        organizationId: params.organizationId,
      },
    };
  }

  async getAccountStatus(): Promise<AccountStatus> {
    // Always active for invoice payment
    return {
      accountId: "invoice_provider",
      status: "active",
      chargesEnabled: true,
      payoutsEnabled: false, // Invoices don't have payouts
      onboardingCompleted: true,
    };
  }

  async refreshAccountStatus(): Promise<AccountStatus> {
    // Same as getAccountStatus - always active
    return this.getAccountStatus();
  }

  async disconnectAccount(): Promise<void> {
    // Invoice provider can't be disconnected - no-op
  }

  async createCheckoutSession(params: CheckoutSessionParams): Promise<CheckoutSessionResult> {
    // Invoice payments don't need a checkout session like Stripe
    // The checkout happens through the behavior-driven checkout flow
    const sessionId = `inv_session_${Date.now()}`;
    return {
      sessionId,
      providerSessionId: sessionId,
      expiresAt: Date.now() + 24 * 60 * 60 * 1000, // 24 hours
      metadata: {
        productId: params.productId,
        productName: params.productName,
      },
    };
  }

  async verifyCheckoutPayment(sessionId: string): Promise<PaymentVerificationResult> {
    // Invoice payments are verified when the invoice is paid
    // For invoice flow, payment is "pending" until invoice is paid
    return {
      success: true,
      paymentId: sessionId,
      amount: 0,
      currency: "usd",
      metadata: {
        status: "pending",
      },
    };
  }

  async createInvoice(params: InvoiceParams): Promise<InvoiceResult> {
    // This is handled by completeCheckoutAndFulfill via createSimpleInvoiceFromCheckout
    const invoiceId = `inv_${Date.now()}`;
    return {
      invoiceId,
      providerInvoiceId: invoiceId,
      hostedInvoiceUrl: "", // Will be set by createSimpleInvoiceFromCheckout
      status: "draft",
      amountDue: params.items.reduce((sum, item) => sum + item.unitPrice * item.quantity, 0),
      currency: "usd",
    };
  }

  async sendInvoice(_invoiceId: string): Promise<InvoiceSendResult> {
    // This is handled by completeCheckoutAndFulfill via sendOrderConfirmationEmail
    return {
      success: true,
      sentAt: Date.now(),
      sentTo: "", // Will be set by actual email send
    };
  }

  async markInvoiceAsPaid(): Promise<void> {
    // Invoice marking is handled by invoicingOntology.markInvoiceAsPaid
  }

  async handleWebhook(): Promise<WebhookHandlingResult> {
    // Invoice payments don't use webhooks in the same way as Stripe
    return {
      success: true,
      actionTaken: "other",
      message: "Invoice webhooks are not used",
    };
  }

  async verifyWebhookSignature(): Promise<boolean> {
    // Invoice payments don't use webhook signatures
    return true;
  }
}

/**
 * Factory function to create an invoice provider instance
 */
export function createInvoiceProvider(): InvoicePaymentProvider {
  return new InvoicePaymentProvider();
}
