/**
 * V0 PLATFORM API INTEGRATION - WORLD CLASS EDITION
 *
 * Integrates with v0.dev's Platform API for AI-powered UI generation.
 * Optimized for maximum quality output matching v0.dev directly.
 *
 * Key improvements:
 * - Async mode with polling for complete responses
 * - Minimal system prompt (let v0 be v0)
 * - Always capture demo URL for live preview
 * - Proper error handling and retries
 *
 * v0 Platform API Reference: https://v0.dev/docs/api/platform
 */

import { action, mutation, query, internalAction, internalMutation, internalQuery } from "../_generated/server";
import { v } from "convex/values";
import { Id } from "../_generated/dataModel";
import { requireAuthenticatedUser, getUserContext } from "../rbacHelpers";

const generatedApi: any = require("../_generated/api");

// v0 Platform API base URL
const V0_API_BASE = "https://api.v0.dev/v1";

// Polling configuration for async mode
const POLL_INTERVAL_MS = 2000; // Check every 2 seconds
const MAX_POLL_TIME_MS = 120000; // Max 2 minutes
const MAX_RETRIES = 3;

// ============================================================================
// TYPES
// ============================================================================

/** Response from v0 chat creation */
interface V0ChatResponse {
  id: string;
  webUrl: string;
  /** v0 API uses "pending" | "completed" | "failed"; legacy also returns "generating" | "ready" | "error" */
  status?: "pending" | "completed" | "failed" | "generating" | "ready" | "error";
  latestVersion?: {
    id: string;
    status?: "pending" | "completed" | "failed";
    demoUrl?: string;
    screenshotUrl?: string;
    files?: V0File[];
  };
  messages?: V0Message[];
}

/** A file generated by v0 — matches the v0 Platform API schema */
interface V0File {
  object?: "file";
  name: string;
  content: string;
  locked?: boolean;
  /** Not part of v0 API — computed from name for backwards compatibility */
  path?: string;
  language?: string;
}

/** A message in a v0 chat */
interface V0Message {
  id: string;
  role: "user" | "assistant";
  content: string;
  createdAt: string;
}

/** v0 API error response */
interface V0Error {
  error: {
    message: string;
    code?: string;
  };
}

// ============================================================================
// INTERNAL HELPERS
// ============================================================================

function readV0StoredApiKey(
  customProperties: Record<string, unknown> | undefined
): string | undefined {
  if (!customProperties) {
    return undefined;
  }

  return customProperties.apiKey as string | undefined;
}

function isV0ApiKeyEncrypted(
  customProperties: Record<string, unknown> | undefined
): boolean {
  const encryptedFields = customProperties?.encryptedFields as string[] | undefined;
  return Array.isArray(encryptedFields) && encryptedFields.includes("v0ApiKey");
}

/**
 * Make a request to the v0 Platform API
 */
async function v0Request<T>(
  endpoint: string,
  apiKey: string,
  options: {
    method?: "GET" | "POST" | "PUT" | "DELETE";
    body?: unknown;
  } = {}
): Promise<T> {
  const { method = "GET", body } = options;

  const fetchOptions: RequestInit = {
    method,
    headers: {
      "Authorization": `Bearer ${apiKey}`,
      "Content-Type": "application/json",
    },
  };

  if (body) {
    fetchOptions.body = JSON.stringify(body);
  }

  const response = await fetch(`${V0_API_BASE}${endpoint}`, fetchOptions);

  if (!response.ok) {
    const errorData = await response.json().catch(() => ({})) as V0Error;
    throw new Error(
      errorData.error?.message || `v0 API error: ${response.status} ${response.statusText}`
    );
  }

  return response.json() as Promise<T>;
}

/**
 * Poll for chat completion - wait until v0 finishes generating
 */
async function pollForCompletion(
  chatId: string,
  apiKey: string,
  maxTimeMs: number = MAX_POLL_TIME_MS
): Promise<V0ChatResponse> {
  const startTime = Date.now();

  // Small initial delay to let v0 process the request
  await new Promise(resolve => setTimeout(resolve, 1000));

  let pollCount = 0;
  while (Date.now() - startTime < maxTimeMs) {
    pollCount++;
    console.log(`[v0:poll] Polling chat ${chatId}, attempt ${pollCount}...`);

    try {
      const response = await v0Request<V0ChatResponse>(`/chats/${chatId}`, apiKey);

      const versionStatus = response.latestVersion?.status;
      console.log(`[v0:poll] Got response:`, {
        status: response.status,
        versionStatus,
        hasLatestVersion: !!response.latestVersion,
        hasDemoUrl: !!response.latestVersion?.demoUrl,
        filesCount: response.latestVersion?.files?.length || 0,
      });

      // Check if generation is complete (v0 API uses "completed"/"failed", legacy uses "ready"/"error")
      if (response.status === "completed" || response.status === "ready" || response.status === "error" || response.status === "failed") {
        return response;
      }

      // Also check version-level status
      if (versionStatus === "completed" || versionStatus === "failed") {
        return response;
      }

      // If no status field, check for latestVersion with files (legacy check)
      if (response.latestVersion?.files && response.latestVersion.files.length > 0) {
        return response;
      }
    } catch (pollError) {
      console.error(`[v0:poll] Error polling:`, pollError instanceof Error ? pollError.message : pollError);
      // Continue polling on error (might be temporary)
    }

    // Wait before next poll
    await new Promise(resolve => setTimeout(resolve, POLL_INTERVAL_MS));
  }

  // Timeout - fetch final state
  console.log(`[v0:poll] Timeout reached, fetching final state...`);
  return v0Request<V0ChatResponse>(`/chats/${chatId}`, apiKey);
}

/**
 * Ensure files are present in the response.
 * If latestVersion.files is empty after completion, do one more GET.
 * v0 sometimes returns completion status before files are available.
 */
async function ensureFiles(
  response: V0ChatResponse,
  apiKey: string
): Promise<V0ChatResponse> {
  if (response.latestVersion?.files && response.latestVersion.files.length > 0) {
    console.log(`[v0:ensureFiles] Files already present: ${response.latestVersion.files.length}`);
    return response;
  }

  console.log(`[v0:ensureFiles] No files in response, retrying GET /chats/${response.id}...`);

  // Wait a moment then re-fetch — files may become available shortly after completion
  for (let retry = 0; retry < 3; retry++) {
    await new Promise(resolve => setTimeout(resolve, 2000 * (retry + 1)));

    try {
      const refetch = await v0Request<V0ChatResponse>(`/chats/${response.id}`, apiKey);
      const fileCount = refetch.latestVersion?.files?.length || 0;
      console.log(`[v0:ensureFiles] Retry ${retry + 1}: got ${fileCount} files`);

      if (fileCount > 0) {
        return refetch;
      }
    } catch (err) {
      console.error(`[v0:ensureFiles] Retry ${retry + 1} failed:`, err instanceof Error ? err.message : err);
    }
  }

  console.warn(`[v0:ensureFiles] Could not retrieve files after 3 retries`);
  return response;
}

/**
 * Build a MINIMAL system prompt
 * Key insight: v0 works best with minimal context - let it do what it does best
 */
function buildMinimalSystemPrompt(orgName?: string): string {
  // Keep it SIMPLE - v0's native capabilities are superior
  // Only add essential context, nothing more
  return `Build a beautiful, modern, production-ready React component using:
- TypeScript with proper types
- Tailwind CSS for styling
- shadcn/ui components when appropriate
- Responsive design (mobile-first)
- Clean, maintainable code

${orgName ? `This is for: ${orgName}` : ""}

Focus on excellent UX and visual design. Make it look professional and polished.`;
}

/**
 * Build system prompt with optional brand context
 * Only adds brand info if it will genuinely improve the output
 */
function buildSystemPromptWithBrand(
  orgName?: string,
  brandVoice?: { tone?: string; tagline?: string }
): string {
  const base = buildMinimalSystemPrompt(orgName);

  if (!brandVoice?.tone && !brandVoice?.tagline) {
    return base;
  }

  return `${base}

${brandVoice?.tagline ? `Brand tagline: "${brandVoice.tagline}"` : ""}
${brandVoice?.tone ? `Brand tone: ${brandVoice.tone}` : ""}`;
}

// ============================================================================
// V0 SETTINGS MANAGEMENT
// ============================================================================

/**
 * Get v0 integration settings for an organization
 */
export const getV0Settings = query({
  args: {
    sessionId: v.string(),
    organizationId: v.id("organizations"),
  },
  handler: async (ctx, args) => {
    await requireAuthenticatedUser(ctx, args.sessionId);

    const v0Settings = await ctx.db
      .query("objects")
      .withIndex("by_org_type", q =>
        q.eq("organizationId", args.organizationId)
          .eq("type", "integration_settings")
      )
      .filter(q => q.eq(q.field("subtype"), "v0"))
      .first();

    return {
      enabled: v0Settings?.customProperties?.enabled ?? false,
      hasApiKey: !!(v0Settings?.customProperties?.apiKey),
    };
  },
});

/**
 * Save v0 integration settings for an organization
 */
export const saveV0Settings = mutation({
  args: {
    sessionId: v.string(),
    organizationId: v.id("organizations"),
    apiKey: v.optional(v.string()),
    enabled: v.boolean(),
  },
  handler: async (ctx, args) => {
    const { userId } = await requireAuthenticatedUser(ctx, args.sessionId);

    const userContext = await getUserContext(ctx, userId, args.organizationId);
    if (!userContext.isGlobal && userContext.roleName !== "admin" && userContext.roleName !== "owner") {
      throw new Error("Not authorized: Admin or owner role required");
    }

    const existing = await ctx.db
      .query("objects")
      .withIndex("by_org_type", q =>
        q.eq("organizationId", args.organizationId)
          .eq("type", "integration_settings")
      )
      .filter(q => q.eq(q.field("subtype"), "v0"))
      .first();

    const customProperties: Record<string, unknown> = {
      ...((existing?.customProperties as Record<string, unknown> | undefined) || {}),
      enabled: args.enabled,
    };

    if (args.apiKey !== undefined) {
      const normalizedApiKey = args.apiKey.trim();
      if (!normalizedApiKey) {
        delete customProperties.apiKey;
        delete customProperties.apiKeyPrefix;
        delete customProperties.credentialSource;
        delete customProperties.encryptedFields;
      } else {
        const encryptedApiKey = await (ctx as any).runAction(
          generatedApi.internal.oauth.encryption.encryptToken,
          { plaintext: normalizedApiKey }
        ) as string;

        customProperties.apiKey = encryptedApiKey;
        customProperties.apiKeyPrefix = normalizedApiKey.slice(0, 12);
        customProperties.credentialSource = "object_settings";
        customProperties.encryptedFields = ["v0ApiKey"];
      }
    }

    if (existing) {
      await ctx.db.patch(existing._id, {
        customProperties,
        updatedAt: Date.now(),
      });
    } else {
      await ctx.db.insert("objects", {
        organizationId: args.organizationId,
        type: "integration_settings",
        subtype: "v0",
        name: "v0 Integration Settings",
        status: "active",
        customProperties,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      });
    }

    return { success: true };
  },
});

// ============================================================================
// CHAT CREATION & MANAGEMENT
// ============================================================================

/**
 * Create a new v0 chat - WORLD CLASS VERSION
 *
 * Key improvements:
 * 1. Uses async mode with polling for complete responses
 * 2. Minimal system prompt for maximum v0 quality
 * 3. Retries on failure
 * 4. Always waits for demo URL
 */
export const createChat = action({
  args: {
    sessionId: v.string(),
    organizationId: v.id("organizations"),
    message: v.string(),
  },
  handler: async (ctx, args): Promise<{
    chatId: string;
    webUrl: string;
    demoUrl?: string;
    files?: V0File[];
    assistantMessage?: string;
  }> => {
    // Verify authentication
    const authResult = await (ctx as any).runQuery(generatedApi.internal.integrations.v0.verifySession, {
      sessionId: args.sessionId,
    });

    if (!authResult.valid) {
      throw new Error("Invalid or expired session");
    }

    // Get v0 API key
    const apiKey = await (ctx as any).runAction(generatedApi.internal.integrations.v0.getApiKeyInternal, {
      organizationId: args.organizationId,
    });

    if (!apiKey) {
      throw new Error("v0 API key not configured. Please add your v0 API key in integration settings.");
    }

    // Get organization name for minimal context
    const org = await (ctx as any).runQuery(generatedApi.internal.integrations.v0.getOrgNameInternal, {
      organizationId: args.organizationId,
    });

    // Build MINIMAL system prompt - let v0 shine
    const systemPrompt = buildMinimalSystemPrompt(org?.name);

    let lastError: Error | null = null;

    // Retry loop for reliability
    for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
      try {
        // Create chat with ASYNC mode - this is the key fix!
        const createResponse = await v0Request<V0ChatResponse>("/chats", apiKey, {
          method: "POST",
          body: {
            message: args.message,
            system: systemPrompt,
            chatPrivacy: "private",
            // Use async mode for complete responses
            responseMode: "async",
          },
        });

        // Poll for completion - wait for v0 to finish generating
        const finalResponse = await pollForCompletion(createResponse.id, apiKey);

        // Extract assistant message
        const assistantMessage = finalResponse.messages
          ?.filter(m => m.role === "assistant")
          .pop()?.content || "I've created your design!";

        // Store the chat reference AND create aiConversation for history
        if (authResult.userId) {
          await (ctx as any).runMutation(generatedApi.internal.integrations.v0.storeChatReference, {
            organizationId: args.organizationId,
            userId: authResult.userId,
            v0ChatId: finalResponse.id,
            webUrl: finalResponse.webUrl,
            demoUrl: finalResponse.latestVersion?.demoUrl || undefined,
            initialMessage: args.message,
            userMessageContent: args.message,
            assistantMessageContent: assistantMessage,
          });
        }

        return {
          chatId: finalResponse.id,
          webUrl: finalResponse.webUrl,
          demoUrl: finalResponse.latestVersion?.demoUrl,
          files: finalResponse.latestVersion?.files,
          assistantMessage,
        };
      } catch (error) {
        lastError = error instanceof Error ? error : new Error(String(error));
        console.error(`[v0] Attempt ${attempt + 1} failed:`, lastError.message);

        // Wait before retry (exponential backoff)
        if (attempt < MAX_RETRIES - 1) {
          await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, attempt)));
        }
      }
    }

    throw lastError || new Error("Failed to create v0 chat after retries");
  },
});

/**
 * Send a follow-up message to an existing v0 chat
 */
export const sendMessage = action({
  args: {
    sessionId: v.string(),
    organizationId: v.id("organizations"),
    chatId: v.string(),
    message: v.string(),
  },
  handler: async (ctx, args): Promise<{
    demoUrl?: string;
    files?: V0File[];
    assistantMessage?: string;
  }> => {
    // Verify authentication
    const authResult = await (ctx as any).runQuery(generatedApi.internal.integrations.v0.verifySession, {
      sessionId: args.sessionId,
    });

    if (!authResult.valid) {
      throw new Error("Invalid or expired session");
    }

    // Get v0 API key
    const apiKey = await (ctx as any).runAction(generatedApi.internal.integrations.v0.getApiKeyInternal, {
      organizationId: args.organizationId,
    });

    if (!apiKey) {
      throw new Error("v0 API key not configured");
    }

    // Send message
    const response = await v0Request<V0ChatResponse>(`/chats/${args.chatId}/messages`, apiKey, {
      method: "POST",
      body: { message: args.message },
    });

    // Poll for completion
    const finalResponse = await pollForCompletion(args.chatId, apiKey);

    // Extract assistant message
    const assistantMessage = finalResponse.messages
      ?.filter(m => m.role === "assistant")
      .pop()?.content;

    return {
      demoUrl: finalResponse.latestVersion?.demoUrl,
      files: finalResponse.latestVersion?.files,
      assistantMessage,
    };
  },
});

/**
 * Get details of a v0 chat
 */
export const getChat = action({
  args: {
    sessionId: v.string(),
    organizationId: v.id("organizations"),
    chatId: v.string(),
  },
  handler: async (ctx, args): Promise<{
    webUrl: string;
    demoUrl?: string;
    files?: V0File[];
    messages?: V0Message[];
  }> => {
    const authResult = await (ctx as any).runQuery(generatedApi.internal.integrations.v0.verifySession, {
      sessionId: args.sessionId,
    });

    if (!authResult.valid) {
      throw new Error("Invalid or expired session");
    }

    const apiKey = await (ctx as any).runAction(generatedApi.internal.integrations.v0.getApiKeyInternal, {
      organizationId: args.organizationId,
    });

    if (!apiKey) {
      throw new Error("v0 API key not configured");
    }

    const response = await v0Request<V0ChatResponse>(`/chats/${args.chatId}`, apiKey);

    return {
      webUrl: response.webUrl,
      demoUrl: response.latestVersion?.demoUrl,
      files: response.latestVersion?.files,
      messages: response.messages,
    };
  },
});

/**
 * Get chat history for an organization
 */
export const getChatHistory = query({
  args: {
    sessionId: v.string(),
    organizationId: v.id("organizations"),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    await requireAuthenticatedUser(ctx, args.sessionId);

    const limit = args.limit || 20;

    const chats = await ctx.db
      .query("objects")
      .withIndex("by_org_type", q =>
        q.eq("organizationId", args.organizationId)
          .eq("type", "v0_chat")
      )
      .order("desc")
      .take(limit);

    return chats.map(chat => ({
      id: chat._id,
      v0ChatId: chat.customProperties?.v0ChatId,
      webUrl: chat.customProperties?.webUrl,
      initialMessage: chat.customProperties?.initialMessage,
      createdAt: chat.createdAt,
    }));
  },
});

// ============================================================================
// INTERNAL QUERIES & MUTATIONS
// ============================================================================

/**
 * Internal: Verify session is valid
 */
export const verifySession = internalQuery({
  args: {
    sessionId: v.string(),
  },
  handler: async (ctx, args): Promise<{ valid: boolean; userId?: Id<"users"> }> => {
    const session = await ctx.db.get(args.sessionId as Id<"sessions">);

    if (!session || !session.userId || session.expiresAt <= Date.now()) {
      return { valid: false };
    }

    return { valid: true, userId: session.userId };
  },
});

/**
 * Internal raw query: v0 API key as stored (encrypted-at-rest payload).
 */
export const getApiKeyStoredInternal = internalQuery({
  args: {
    organizationId: v.id("organizations"),
  },
  handler: async (ctx, args): Promise<{
    apiKey: string | undefined;
    encryptedFields: string[] | undefined;
  } | null> => {
    const v0Settings = await ctx.db
      .query("objects")
      .withIndex("by_org_type", q =>
        q.eq("organizationId", args.organizationId)
          .eq("type", "integration_settings")
      )
      .filter(q => q.eq(q.field("subtype"), "v0"))
      .first();

    const customProperties = v0Settings?.customProperties as
      | Record<string, unknown>
      | undefined;
    if (!customProperties) {
      return null;
    }

    return {
      apiKey: readV0StoredApiKey(customProperties),
      encryptedFields: customProperties.encryptedFields as string[] | undefined,
    };
  },
});

/**
 * Internal: Get v0 API key for an organization (decrypt-on-use boundary).
 */
export const getApiKeyInternal = internalAction({
  args: {
    organizationId: v.id("organizations"),
  },
  handler: async (ctx, args): Promise<string | null> => {
    const stored = await (ctx as any).runQuery(
      generatedApi.internal.integrations.v0.getApiKeyStoredInternal,
      { organizationId: args.organizationId }
    );

    if (stored?.apiKey) {
      const shouldDecrypt =
        Array.isArray(stored.encryptedFields) &&
        stored.encryptedFields.includes("v0ApiKey");
      if (!shouldDecrypt) {
        return stored.apiKey as string;
      }

      const decryptedApiKey = await (ctx as any).runAction(
        generatedApi.internal.oauth.encryption.decryptToken,
        { encrypted: stored.apiKey }
      );
      return typeof decryptedApiKey === "string" ? decryptedApiKey : null;
    }

    return process.env.V0_API_KEY || null;
  },
});

/**
 * Internal: Get organization name (for minimal context)
 */
export const getOrgNameInternal = internalQuery({
  args: {
    organizationId: v.id("organizations"),
  },
  handler: async (ctx, args): Promise<{ name: string } | null> => {
    const org = await ctx.db.get(args.organizationId);
    if (!org) return null;
    return { name: org.name };
  },
});

/**
 * Generate a URL-friendly slug from a title
 */
function generateSlug(title: string): string {
  const base = title
    .toLowerCase()
    .replace(/[^a-z0-9\s-]/g, "")
    .replace(/\s+/g, "-")
    .replace(/-+/g, "-")
    .slice(0, 50);

  // Add random suffix for uniqueness
  const suffix = Math.random().toString(36).substring(2, 8);
  return `${base}-${suffix}`;
}

/**
 * Internal: Store a chat reference AND create an aiConversation for history
 */
export const storeChatReference = internalMutation({
  args: {
    organizationId: v.id("organizations"),
    userId: v.id("users"),
    v0ChatId: v.string(),
    webUrl: v.string(),
    demoUrl: v.optional(v.string()),
    initialMessage: v.string(),
    userMessageContent: v.string(),
    assistantMessageContent: v.string(),
    existingConversationId: v.optional(v.id("aiConversations")),
  },
  handler: async (ctx, args): Promise<{ conversationId: Id<"aiConversations">; slug: string }> => {
    const now = Date.now();

    // Store v0 chat reference in objects table
    await ctx.db.insert("objects", {
      organizationId: args.organizationId,
      type: "v0_chat",
      subtype: "generation",
      name: args.initialMessage.slice(0, 100) + (args.initialMessage.length > 100 ? "..." : ""),
      status: "active",
      customProperties: {
        v0ChatId: args.v0ChatId,
        webUrl: args.webUrl,
        demoUrl: args.demoUrl,
        initialMessage: args.initialMessage,
        createdBy: args.userId,
      },
      createdAt: now,
      updatedAt: now,
    });

    // If we have an existing conversation, just add messages to it
    if (args.existingConversationId) {
      const existingConv = await ctx.db.get(args.existingConversationId);
      if (existingConv) {
        // Add user message
        await ctx.db.insert("aiMessages", {
          conversationId: args.existingConversationId,
          role: "user",
          content: args.userMessageContent,
          timestamp: now,
        });

        // Add assistant message
        await ctx.db.insert("aiMessages", {
          conversationId: args.existingConversationId,
          role: "assistant",
          content: args.assistantMessageContent,
          timestamp: now + 1,
        });

        // Update conversation with latest v0 metadata
        await ctx.db.patch(args.existingConversationId, {
          v0ChatId: args.v0ChatId,
          v0WebUrl: args.webUrl,
          ...(args.demoUrl && { v0DemoUrl: args.demoUrl }),
          updatedAt: now,
        });

        return {
          conversationId: args.existingConversationId,
          slug: existingConv.slug || "",
        };
      }
    }

    // Create a new aiConversation for chat history with v0 metadata
    const title = `v0: ${args.initialMessage.slice(0, 50)}${args.initialMessage.length > 50 ? "..." : ""}`;
    const slug = generateSlug(title);

    const conversationId = await ctx.db.insert("aiConversations", {
      organizationId: args.organizationId,
      userId: args.userId,
      title,
      slug,
      status: "active",
      aiProvider: "v0",
      v0ChatId: args.v0ChatId,
      v0WebUrl: args.webUrl,
      v0DemoUrl: args.demoUrl,
      createdAt: now,
      updatedAt: now,
    });

    // Add user message
    await ctx.db.insert("aiMessages", {
      conversationId,
      role: "user",
      content: args.userMessageContent,
      timestamp: now,
    });

    // Add assistant message
    await ctx.db.insert("aiMessages", {
      conversationId,
      role: "assistant",
      content: args.assistantMessageContent,
      timestamp: now + 1,
    });

    return { conversationId, slug };
  },
});

// ============================================================================
// BUILDER INTEGRATION - WORLD CLASS VERSION
// ============================================================================

/**
 * Builder-compatible v0 chat action - WORLD CLASS EDITION
 *
 * This is the main entry point for the builder to use v0.
 *
 * Key improvements over previous version:
 * 1. ASYNC mode with polling - complete responses, not truncated
 * 2. MINIMAL system prompt - let v0's native quality shine
 * 3. ALWAYS get demo URL - essential for preview
 * 4. Better error handling with retries
 * 5. Clean response formatting
 */
export const builderChat = action({
  args: {
    organizationId: v.id("organizations"),
    userId: v.id("users"),
    message: v.string(),
    v0ChatId: v.optional(v.string()),
    existingConversationId: v.optional(v.id("aiConversations")),
    // Optional: pass brand context if user has it configured
    brandContext: v.optional(v.object({
      tagline: v.optional(v.string()),
      tone: v.optional(v.string()),
    })),
  },
  handler: async (ctx, args): Promise<{
    v0ChatId: string;
    webUrl: string;
    message: string;
    demoUrl: string | null;
    files: V0File[];
    conversationId: Id<"aiConversations">;
    slug: string;
  }> => {
    // Get v0 API key
    const apiKey = await (ctx as any).runAction(generatedApi.internal.integrations.v0.getApiKeyInternal, {
      organizationId: args.organizationId,
    });

    if (!apiKey) {
      throw new Error(
        "v0 API key not configured. Add your v0 API key in Settings > Integrations > v0."
      );
    }

    let lastError: Error | null = null;

    // ========================================================================
    // FOLLOW-UP MESSAGE (existing chat)
    // ========================================================================
    if (args.v0ChatId) {
      for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
        try {
          // Send the message
          await v0Request<V0ChatResponse>(
            `/chats/${args.v0ChatId}/messages`,
            apiKey,
            {
              method: "POST",
              body: { message: args.message },
            }
          );

          // Poll for completion
          let response = await pollForCompletion(args.v0ChatId, apiKey);

          // Ensure files are present (v0 may need a re-fetch)
          response = await ensureFiles(response, apiKey);

          // Get the latest assistant message
          const assistantMessage = response.messages
            ?.filter(m => m.role === "assistant")
            .pop()?.content || "Here's the updated design!";

          // Store follow-up messages in chat history
          const chatResult = await (ctx as any).runMutation(generatedApi.internal.integrations.v0.storeChatReference, {
            organizationId: args.organizationId,
            userId: args.userId,
            v0ChatId: args.v0ChatId,
            webUrl: response.webUrl,
            demoUrl: response.latestVersion?.demoUrl || undefined,
            initialMessage: args.message,
            userMessageContent: args.message,
            assistantMessageContent: assistantMessage,
            existingConversationId: args.existingConversationId,
          });

          const files = response.latestVersion?.files || [];
          console.log(`[v0:followup] Returning ${files.length} files`);

          return {
            v0ChatId: args.v0ChatId,
            webUrl: response.webUrl,
            message: assistantMessage,
            demoUrl: response.latestVersion?.demoUrl || null,
            files,
            conversationId: chatResult.conversationId,
            slug: chatResult.slug,
          };
        } catch (error) {
          lastError = error instanceof Error ? error : new Error(String(error));
          console.error(`[v0:followup] Attempt ${attempt + 1} failed:`, lastError.message);

          if (attempt < MAX_RETRIES - 1) {
            await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, attempt)));
          }
        }
      }

      throw lastError || new Error("Failed to send v0 message after retries");
    }

    // ========================================================================
    // NEW CHAT
    // ========================================================================

    // Get organization name for minimal context
    const org = await (ctx as any).runQuery(generatedApi.internal.integrations.v0.getOrgNameInternal, {
      organizationId: args.organizationId,
    });

    // Build MINIMAL system prompt
    // This is the key to matching v0.dev quality - don't overload with context!
    const systemPrompt = args.brandContext
      ? buildSystemPromptWithBrand(org?.name, args.brandContext)
      : buildMinimalSystemPrompt(org?.name);

    for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
      try {
        // Create chat with ASYNC mode - essential for quality!
        console.log("[v0:new] Creating chat with message:", args.message.substring(0, 100));

        // Make the POST request and log raw response for debugging
        const fetchResponse = await fetch(`${V0_API_BASE}/chats`, {
          method: "POST",
          headers: {
            "Authorization": `Bearer ${apiKey}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            message: args.message,
            system: systemPrompt,
            chatPrivacy: "private",
          }),
        });

        const responseText = await fetchResponse.text();
        console.log("[v0:new] Raw response status:", fetchResponse.status);
        console.log("[v0:new] Raw response body:", responseText.substring(0, 500));

        if (!fetchResponse.ok) {
          throw new Error(`v0 API error: ${fetchResponse.status} - ${responseText}`);
        }

        const createResponse = JSON.parse(responseText) as V0ChatResponse;

        console.log("[v0:new] Chat created:", {
          id: createResponse.id,
          webUrl: createResponse.webUrl,
          status: createResponse.status,
          hasLatestVersion: !!createResponse.latestVersion,
          hasDemoUrl: !!createResponse.latestVersion?.demoUrl,
        });

        // If we already have a demo URL, use it directly (sync mode)
        if (createResponse.latestVersion?.demoUrl) {
          console.log("[v0:new] Got immediate demo URL, ensuring files are present...");

          // Even with immediate demoUrl, files may not be ready yet
          const withFiles = await ensureFiles(createResponse, apiKey);

          const assistantMessage = withFiles.messages
            ?.filter(m => m.role === "assistant")
            .pop()?.content || "I've created your design! Check the preview to see it live.";

          // Store chat reference AND create aiConversation for history
          const chatResult = await (ctx as any).runMutation(generatedApi.internal.integrations.v0.storeChatReference, {
            organizationId: args.organizationId,
            userId: args.userId,
            v0ChatId: withFiles.id,
            webUrl: withFiles.webUrl,
            demoUrl: withFiles.latestVersion?.demoUrl || createResponse.latestVersion.demoUrl,
            initialMessage: args.message,
            userMessageContent: args.message,
            assistantMessageContent: assistantMessage,
            existingConversationId: args.existingConversationId,
          });

          const files = withFiles.latestVersion?.files || [];
          console.log(`[v0:new] Immediate path returning ${files.length} files`);

          return {
            v0ChatId: withFiles.id,
            webUrl: withFiles.webUrl,
            message: assistantMessage,
            demoUrl: withFiles.latestVersion?.demoUrl || createResponse.latestVersion.demoUrl,
            files,
            conversationId: chatResult.conversationId,
            slug: chatResult.slug,
          };
        }

        // Poll until v0 finishes generating
        let response = await pollForCompletion(createResponse.id, apiKey);

        console.log("[v0:new] Poll completed:", {
          status: response.status,
          hasDemoUrl: !!response.latestVersion?.demoUrl,
          filesCount: response.latestVersion?.files?.length || 0,
        });

        // Ensure files are present (v0 may need a re-fetch)
        response = await ensureFiles(response, apiKey);

        // Get the assistant message
        const assistantMessage = response.messages
          ?.filter(m => m.role === "assistant")
          .pop()?.content || "I've created your design! Check the preview to see it live.";

        // Store chat reference AND create aiConversation for history
        const chatResult = await (ctx as any).runMutation(generatedApi.internal.integrations.v0.storeChatReference, {
          organizationId: args.organizationId,
          userId: args.userId,
          v0ChatId: response.id,
          webUrl: response.webUrl,
          demoUrl: response.latestVersion?.demoUrl || undefined,
          initialMessage: args.message,
          userMessageContent: args.message,
          assistantMessageContent: assistantMessage,
          existingConversationId: args.existingConversationId,
        });

        const files = response.latestVersion?.files || [];
        console.log(`[v0:new] Polled path returning ${files.length} files`);

        return {
          v0ChatId: response.id,
          webUrl: response.webUrl,
          message: assistantMessage,
          demoUrl: response.latestVersion?.demoUrl || null,
          files,
          conversationId: chatResult.conversationId,
          slug: chatResult.slug,
        };
      } catch (error) {
        lastError = error instanceof Error ? error : new Error(String(error));
        console.error(`[v0:new] Attempt ${attempt + 1} failed:`, lastError.message);

        if (attempt < MAX_RETRIES - 1) {
          await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, attempt)));
        }
      }
    }

    throw lastError || new Error("Failed to create v0 chat after retries");
  },
});

// ============================================================================
// LEGACY SUPPORT - Keep old function signatures working
// ============================================================================

/**
 * Internal: Get organization context (legacy - simplified)
 * Kept for backward compatibility but now returns minimal data
 */
export const getOrgContextInternal = internalQuery({
  args: {
    organizationId: v.id("organizations"),
  },
  handler: async (ctx, args) => {
    const org = await ctx.db.get(args.organizationId);
    if (!org) {
      throw new Error("Organization not found");
    }

    // Return minimal context - v0 works better this way
    return {
      id: args.organizationId,
      name: org.name,
    };
  },
});
