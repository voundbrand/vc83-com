# Analysis: The "God Table" & Deep Type Instantiation (TS2589)

## The Core Problem
The codebase effectively uses a single "God Table" (`objects` in `ontologySchemas.ts`) to store disparate entities (Events, Transactions, Products, Contacts). This table uses `v.any()` for its `customProperties` field to allow flexibility.

```typescript
// convex/schemas/ontologySchemas.ts
export const objects = defineTable({
  // ...
  customProperties: v.optional(v.record(v.string(), v.any())),
  // ...
});
```

## Why This Breaks TypeScript
Convex generates TypeScript types based on your schema. When you use `v.any()`, it technically allows anything. However, the problem arises when you have **Recursive Interactions** or **Rich Object Expansion** in your queries.

1.  **Inference Explosion**: When you query `objects`, Convex returns a `Doc<"objects">`.
2.  **Recursive Relationships**: If an `Event` object links to a `Sponsor` (which is also an `object`), and you try to infer the type of "Event with Sponsors", TypeScript attempts to unwrap the `customProperties`.
3.  **The "Any" Trap**: `v.any()` doesn't just mean "anything", it disables type narrowing in a way that, when combined with complex union types (generated by `defineSchema`), causes TypeScript's mapped types to loop infinitely trying to resolve the final structure.
4.  **Result**: `TS2589: Type instantiation is excessively deep and possibly infinite`.

## Evidence
We see this manifested in `convex/transactionHelpers.ts`:
```typescript
// @ts-ignore - Deep type instantiation in Convex generated types
const session = await (ctx as any).runQuery(...)
```
And `convex/actions/apiKeys.ts`:
```typescript
// @ts-ignore
const session = await ctx.runQuery(...)
```
And `src/hooks/use-namespace-translations.ts`.

All these files interact with the `objects` table (or queries that return `objects`), leading to the compiler hitting its recursion limit.

## The Solution Strategy
We cannot easily "fix" the schema without a massive migration. Therefore, we must fix the **Code Interaction Pattern**.

**We need a "Type Firewall".**
Instead of letting Convex *infer* the return type of a helper function (which carries the infinite recursion metadata), we must **explicitly define** the return interface. This stops TypeScript from trying to "look inside" the black box of the query logic.
