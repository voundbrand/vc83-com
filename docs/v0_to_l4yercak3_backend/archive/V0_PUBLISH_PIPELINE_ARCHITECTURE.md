# V0 Publish Pipeline Architecture

> Complete specification for the v0 → GitHub → Vercel deployment pipeline.
> Last updated: 2026-01-31

## Pipeline Overview

```
User builds app in Builder Chat (v0)
    ↓
v0 generates files → stored in builderFiles table (Convex)
    ↓
User clicks "Publish" in dropdown
    ↓
GitHub: Atomic commit via Git Trees API
    ↓
  patchV0CompatibilityIssues() runs:
    Phase 1a: Geist font imports → geist npm package
    Phase 1b: Tailwind v4 CSS → v3 compatible
    Phase 1c: Tailwind config → shadcn/ui theme
    Phase 2:  Scan for @/components/ui/* → generate stubs
    Phase 3:  Scan for npm imports → merge into package.json
    ↓
Vercel: Create project + auto-deploy (or manual trigger fallback)
    ↓
Polling: 5s intervals, up to 10 minutes
    ↓
Success → show production URL
  OR
Error → collapsible error accordion + "Fix in Chat" → self-heal loop
```

---

## File Map

| File | Layer | Purpose |
|------|-------|---------|
| `convex/integrations/v0.ts` | Backend | v0 API integration, chat polling, file extraction |
| `convex/integrations/github.ts` | Backend | Repo creation, file patching, atomic commits |
| `convex/integrations/vercel.ts` | Backend | Project creation, env vars, deploy polling, build logs |
| `convex/integrations/selfHealDeploy.ts` | Backend | LLM-based surgical fixes, v0 regeneration fallback |
| `convex/integrations/selfHealChat.ts` | Backend | Chat integration for self-heal flow |
| `src/lib/scaffold-generators/thin-client.ts` | Frontend | Wizard scaffold file generator |
| `src/components/builder/publish-dropdown.tsx` | Frontend | Deployment UI, polling, error display |
| `src/contexts/builder-context.tsx` | Frontend | Builder state, v0 integration, app lifecycle |

---

## 1. V0 Integration (`convex/integrations/v0.ts`)

### Flow
```
User message → builderChat() action
    → Creates/continues v0 chat
    → Async polling (2s intervals, 120s max)
    → Extracts files from v0 response
    → Stores in builderFiles table + aiConversations
```

### Key Functions
- **`builderChat(message, v0ChatId?, conversationId?, brandContext?)`** — Main entry. Creates or continues v0 chat, polls for completion, extracts files.
- **`pollForCompletion(chatId, maxTimeMs)`** — Polls v0 API every 2s. Includes `ensureFiles()` retry since v0 may delay file availability.
- **`storeChatReference(v0ChatId, webUrl, demoUrl, ...)`** — Mutation. Stores chat metadata in `objects` table, creates/updates `aiConversations` record.

### Data Model
```typescript
V0File {
  name: string;
  content: string;
  locked?: boolean;
  path?: string;
  language?: string;
}
```

---

## 2. File Persistence (Builder Context)

### Storage
- **Table**: `builderFiles` in Convex
- **Shape**: `{ appId, path, content, language }`
- **Created by**: `createBuilderApp()` on first v0 response
- **Updated by**: `updateBuilderApp()` on follow-up v0 messages

### Builder App Record
```typescript
// objects table, type: "builder_app", subtype: "v0_generated"
customProperties: {
  v0ChatId: string;          // v0 chat session ID
  v0WebUrl: string;          // v0 editor link
  v0DemoUrl: string;         // Live preview URL
  conversationId: string;    // aiConversations link
  githubRepo?: string;       // Set after first publish
  vercelProjectId?: string;  // Set after first deploy
  deployment?: {
    status: "deploying" | "deployed" | "failed";
    productionUrl?: string;
    deploymentError?: string;
    healState?: HealState;
  };
}
```

---

## 3. GitHub Integration (`convex/integrations/github.ts`)

### Publish Flow

```
createRepoFromBuilderApp(appId, repoName, isPrivate, scaffoldFiles?)
    ↓
1. Get files from builderFiles table
2. Determine scaffold path:
   - Wizard path: args.scaffoldFiles from thin-client.ts (scaffold wins on conflict)
   - Legacy path: inline-generated scaffold files
3. Merge: [...nonConflictingV0Files, ...scaffoldFiles]
4. Run patchV0CompatibilityIssues(allFiles)
5. Atomic commit via Git Trees API
6. Update builder app with githubRepo URL
```

### Two Scaffold Paths

**Wizard Path** (when `args.scaffoldFiles` provided):
- Scaffold files generated by `thin-client.ts` on the frontend
- Passed as `args.scaffoldFiles` to the Convex action
- Scaffold files **win** on path conflict with v0 files (e.g., scaffold provides enhanced `package.json`)

**Legacy Path** (fallback):
- Scaffold files generated inline by functions in `github.ts`
- Used when no `scaffoldFiles` argument provided
- Generates: `package.json`, `.env.example`, `README.md`, `lib/layercake.ts`, `next.config.js`, `tsconfig.json`, `tailwind.config.ts`, `app/layout.tsx`, `app/globals.css`, `app/page.tsx`, `lib/utils.ts`, `components.json`

### `patchV0CompatibilityIssues(files)` — The Compatibility Engine

This function post-processes ALL files before committing to GitHub. It handles the mismatch between what v0 generates (Tailwind v4, modern imports) and what actually builds on Next.js 14.2.5 + Tailwind v3.

#### Phase 1a: Geist Font Patching (`patchGeistFontImports`)

**Problem**: v0 imports Geist from `next/font/google`, but Geist is NOT a Google Font.

**Fix**:
```
// Before (v0 generates):
import { Geist, Geist_Mono } from "next/font/google"
const geist = Geist({ subsets: ["latin"] });

// After (patched):
import { GeistSans } from "geist/font/sans";
import { GeistMono } from "geist/font/mono";
```

Also patches `className` references: `geist.variable` → `GeistSans.variable`, etc.

#### Phase 1b: Tailwind v4 → v3 CSS (`convertGlobalsCssToV3`)

**Problem**: v0 generates Tailwind v4 syntax that doesn't work with Tailwind v3.

**Detection**: File contains `@import 'tailwindcss'` or `@import "tailwindcss"`.

**Fix**: Extracts CSS variables from `:root` and `.dark` blocks, regenerates with:
```css
/* Before (v0 Tailwind v4): */
@import 'tailwindcss';
@import 'tw-animate-css';
@custom-variant dark (&:is(.dark *));
:root { --background: oklch(0.985 0.002 264); ... }
@theme inline { --color-background: var(--background); ... }

/* After (patched to v3): */
@tailwind base;
@tailwind components;
@tailwind utilities;
:root { --background: oklch(0.985 0.002 264); ... }
.dark { ... }
@layer base {
  * { @apply border-border; }
  body { @apply bg-background text-foreground; }
}
```

The oklch values are preserved as-is since the tailwind config references them via `var()`.

#### Phase 1c: Tailwind Config (`generateShadcnTailwindConfig`)

**Triggered when**: globals.css was patched from v4 to v3.

**Generates** a Tailwind config with shadcn/ui theme extensions:
```typescript
// Maps CSS variables to Tailwind utility classes
colors: {
  background: "var(--background)",
  foreground: "var(--foreground)",
  card: { DEFAULT: "var(--card)", foreground: "var(--card-foreground)" },
  primary: { DEFAULT: "var(--primary)", foreground: "var(--primary-foreground)" },
  // ... all semantic colors
},
borderRadius: {
  lg: "var(--radius)",
  md: "calc(var(--radius) - 2px)",
  sm: "calc(var(--radius) - 4px)",
},
plugins: [require("tailwindcss-animate")]
```

#### Phase 2: Shadcn Component Stubs

**Detection**: Scans all `.ts/.tsx/.js/.jsx` files for `from "@/components/ui/[name]"` imports.

**Resolution**:
1. **Pre-built stubs** for: `button`, `card`, `input`, `label`, `badge`, `separator`, `textarea`, `avatar`, `scroll_area`
   - Proper HTML elements and props for each
2. **Generic fallback** (`generateGenericShadcnStub`) for unknown components:
   - Creates `forwardRef<HTMLDivElement, any>` div wrappers
   - Exports component + common sub-components (Trigger, Content, Header, Footer, Title, Description, Close, Item, Group, Value, Viewport, Root)
   - Uses `any` prop type to accept whatever v0 passes (`type`, `collapsible`, `value`, etc.)

#### Phase 3: NPM Import Detection (Experimental)

**Note**: This scanner was built but found to be unreliable in the Convex runtime. The essential packages are now hardcoded in the scaffold `package.json` instead. The scanner remains as a bonus for edge-case packages.

**Approach**: Line-by-line import parsing (no regex `/g` flag due to Convex runtime issues).

**Known Package Registry** (`getKnownPackageVersion`): ~50 packages with pinned versions including all `@radix-ui/*`, animation (`framer-motion`), data (`recharts`, `date-fns`), forms (`react-hook-form`, `zod`), and utility packages.

### Hardcoded Package.json Dependencies

Both scaffold paths include these packages to prevent build failures:

```json
{
  "next": "14.2.5",
  "react": "^18.2.0",
  "react-dom": "^18.2.0",
  "lucide-react": "^0.400.0",
  "geist": "^1.3.0",
  "@vercel/analytics": "^1.3.1",
  "@vercel/speed-insights": "^1.0.12",
  "clsx": "^2.1.0",
  "tailwind-merge": "^2.2.0",
  "class-variance-authority": "^0.7.0",
  "tailwindcss-animate": "^1.0.7",
  "@radix-ui/react-slot": "^1.0.2",
  "@radix-ui/react-accordion": "^1.1.2",
  "@radix-ui/react-dialog": "^1.0.5",
  "@radix-ui/react-dropdown-menu": "^2.0.6",
  "@radix-ui/react-label": "^2.0.2",
  "@radix-ui/react-popover": "^1.0.7",
  "@radix-ui/react-select": "^2.0.0",
  "@radix-ui/react-separator": "^1.0.3",
  "@radix-ui/react-tabs": "^1.0.4",
  "@radix-ui/react-toast": "^1.1.5",
  "@radix-ui/react-tooltip": "^1.0.7"
}
```

### Git Commit Strategy (Atomic)

Uses the Git Trees API for a single atomic commit (avoids 409 SHA conflicts):

```
1. GET /git/ref/heads/{branch}         → parentCommitSha
2. POST /git/blobs (per file)          → blob SHAs
3. POST /git/trees { base_tree, tree } → treeSha
4. POST /git/commits { tree, parents } → commitSha
5. PATCH /git/refs/heads/{branch}      → update branch
```

---

## 4. Vercel Deployment (`convex/integrations/vercel.ts`)

### Deploy Flow

```
deployToVercel(projectName, githubRepo, envVars)
    ↓
1. Create Vercel project (POST /v10/projects)
   - Handles 409 "already exists" by fetching existing
   - Links to GitHub repo
2. Set environment variables (POST /v10/projects/{id}/env?upsert=true)
   - Non-fatal if fails
3. Wait 5s for auto-deployment
4. If no auto-deploy detected → manual trigger:
   POST /v13/deployments { gitSource: { type: "github", repo, ref: "main" } }
5. Return: projectId, deploymentId, deploymentUrl
```

### Manual Deployment Trigger

Vercel's GitHub auto-deploy requires the Vercel GitHub App to be installed. When it's not installed, no webhook fires and no deployment starts. Two fallback points:

1. **In `deployToVercel`**: After 5s wait, if no deployment found, manually triggers via `POST /v13/deployments`
2. **In `checkVercelDeploymentStatus`**: At poll #6 (~30s), fetches project info to find linked repo, then manually triggers deployment

### Polling (`checkVercelDeploymentStatus`)

```
Every 5s:
  GET /v6/deployments?projectId=...&limit=1
    ↓
  readyState === "READY"     → Update app: status="deployed", productionUrl
  readyState === "ERROR"     → Fetch build logs, extract error, suggested fixes
  readyState === "BUILDING"  → Continue polling (at poll #6, trigger manual deploy)
```

### Build Log Extraction

**`fetchBuildLogExcerpt(deploymentId)`**:
- Calls `GET /v3/deployments/{id}/events?direction=backward&limit=100`
- Searches for error markers: "error", "Module not found", "Type error", "npm ERR"
- Returns context lines (2 before, 3 after error)
- Max 1500 chars

**`generateSuggestedFixes(lines)`** — Auto-suggests fixes:
- Missing modules → `npm install` command
- TypeScript errors → "Fix type errors"
- ESLint → "Add disable comments"
- Missing env vars → "Set missing variables"
- npm conflicts → `--legacy-peer-deps`

---

## 5. Publish Dropdown UI (`src/components/builder/publish-dropdown.tsx`)

### State Machine

```
idle
  → pushing_github     (createRepo)
  → creating_project   (deployToVercel)
  → setting_env        (setEnv)
  → deploying          (polling checkVercelDeploymentStatus)
  → ready              (READY → show production URL)
  → error              (ERROR → collapsible error accordion)
```

### Key UI State

```typescript
showErrorDetails: boolean     // Accordion toggle for error tile
showBuildLogs: boolean        // Toggle for build log viewer
buildLogs: string | null      // Raw build log content
suggestedFixes: string[]      // Auto-generated fix suggestions
deploymentIdForLogs: string   // Vercel deployment ID for log fetching
isHealing: boolean            // Self-heal in progress
healResult: { ... }           // Self-heal attempt result
```

### Error Display (Collapsible Accordion)

Both the "active deployment error" and "previous deployment error" sections are collapsible:
- **Collapsed**: Single line with icon + truncated message (80 chars) + chevron
- **Expanded**: Full error + suggested fixes + build logs toggle
- **Scrollable**: `max-h-48 overflow-y-auto` to prevent dropdown overflow
- **Reset**: `showErrorDetails` resets to `false` on new deployment

### Polling

```typescript
// useEffect with 5s interval
pollCountRef.current++;
const status = await checkDeployStatus({
  sessionId, organizationId, appId, vercelProjectId,
  pollCount: pollCountRef.current
});
// Max 120 polls (10 minutes)
```

---

## 6. Self-Healing System

### Architecture

Two modules work together:

- **`selfHealDeploy.ts`** — Core healing logic (LLM analysis + code fixes)
- **`selfHealChat.ts`** — Chat integration (messages + UI state)

### Heal Strategy by Attempt

| Attempt | Strategy | Description |
|---------|----------|-------------|
| 1-2 | `surgical` | LLM (Claude via OpenRouter) analyzes build logs + source, generates targeted code fixes |
| 3 | `v0_regeneration` | Sends build errors back to v0 for full regeneration |

### Surgical Fix Flow

```
1. analyzeBuildError():
   - Get all files from builderFiles table
   - Send to Claude: system prompt + build logs + source code
   - Returns: { rootCause, confidence, fixes[] }
   - Each fix: { filePath, oldContent, newContent, explanation }

2. Apply fixes:
   - bulkUpsertFiles() → update builderFiles table
   - createRepoFromBuilderApp() → push to GitHub
   - Update deployment.status = "deploying"
   - Frontend resumes polling
```

### Heal State Persistence

```typescript
deployment.healState: {
  attemptNumber: number;
  maxAttempts: 3;
  lastBuildLogs: string;
  fixHistory: Array<{ attempt, rootCause, fixes[], success }>;
  status: "idle" | "analyzing" | "fixing" | "deploying" | "succeeded" | "failed";
  deploymentId: string;
  repoName: string;
  isPrivate: boolean;
}
```

Stored on the builder app record — persists across page reloads and dropdown open/close.

### Chat Integration

```
User clicks "Fix in Chat" in error accordion
    ↓
startChatHeal() → contextMessage posted to builder chat
    ↓
runChatHealAttempt() → selfHealDeploy() under the hood
    ↓
Result posted as assistant message
    ↓
Success → resume polling / Failure → show next attempt option
```

---

## 7. Scaffold Generator (`src/lib/scaffold-generators/thin-client.ts`)

### Generated Files (Wizard Path)

**Always generated**:
| File | Purpose |
|------|---------|
| `lib/api.ts` | Typed API wrapper for l4yercak3 platform |
| `lib/utils.ts` | shadcn `cn()` helper |
| `types/index.ts` | TypeScript interfaces |
| `components/providers.tsx` | Client-side providers (Clerk if applicable) |
| `middleware.ts` | Auth + security headers |
| `tailwind.config.ts` | Tailwind config |
| `tsconfig.json` | TypeScript config |
| `next.config.mjs` | Next.js config |
| `postcss.config.mjs` | PostCSS config |
| `app/globals.css` | Global styles with Tailwind directives |
| `app/layout.tsx` | Root layout |
| `app/page.tsx` | Root page placeholder |
| `package.json` | Dependencies (hardcoded v0 common + conditional) |
| `.env.example` | Environment variable template |
| `README.md` | Project documentation |
| `.gitignore` | Git ignore rules |
| `components.json` | shadcn/ui configuration |

**Conditional by API category**:
- `forms` → `lib/forms.ts` + `app/forms/page.tsx`
- `events` → `lib/events.ts` + `app/events/page.tsx`
- `products` → `lib/products.ts` + `app/products/page.tsx`
- `invoices` → `lib/invoicing.ts` + `app/invoices/page.tsx`
- `bookings` → `lib/bookings.ts` + `app/bookings/page.tsx`

**Conditional by payment**: `stripe` → `lib/stripe.ts` + checkout + webhook routes

**Conditional by auth**: `clerk` → Clerk middleware + provider, `nextauth` → NextAuth route

---

## Known Issues & Workarounds

### Import Scanner Unreliable in Convex Runtime
**Issue**: Regex `/g` flag with `matchAll()` and `exec()` while loops produced zero results in the Convex V8 runtime, despite working correctly in Node.js.
**Workaround**: Essential v0 packages hardcoded in both scaffold `package.json` generators. The line-by-line scanner remains as a fallback for edge-case packages.

### Vercel Auto-Deploy Requires GitHub App
**Issue**: Without the Vercel GitHub App installed, pushes to GitHub don't trigger Vercel deployments.
**Workaround**: Manual deployment trigger via `POST /v13/deployments` with `gitSource` at two points: immediately after first deploy attempt, and at poll #6 (~30s).

### v0 Generates Tailwind v4 Syntax
**Issue**: v0 outputs `@import 'tailwindcss'`, `oklch()` colors, `@custom-variant`, and `@theme inline` — incompatible with Tailwind v3 + Next.js 14.2.5.
**Fix**: `convertGlobalsCssToV3()` extracts CSS variables and regenerates with `@tailwind base/components/utilities`. `generateShadcnTailwindConfig()` provides theme mappings.

### Generic Stubs Must Accept Any Props
**Issue**: v0 passes component-specific props (`type`, `collapsible`, `value`, `side`, `align`) that strict `HTMLAttributes` types reject.
**Fix**: Generic stubs use `React.forwardRef<HTMLDivElement, any>` to accept all props without TypeScript errors.

### Token Decryption Errors
**Issue**: Logs show `Token decryption failed: Invalid initialization vector` for some OAuth tokens.
**Workaround**: Fallback to plaintext token: `[Vercel] Decrypt failed, trying token as plaintext (legacy)`.

---

## Architecture Decisions

### Why Hardcode Dependencies Instead of Dynamic Scanning
Dynamic import scanning was attempted (regex → exec → line-by-line parsing) but was unreliable in the Convex runtime. Since v0 uses a predictable set of packages (shadcn/ui + Radix + lucide-react + Vercel analytics), hardcoding them is more reliable and adds minimal bundle bloat (~20 packages, all tree-shakeable).

### Why Atomic Git Commits
Sequential per-file commits via the GitHub API caused 409 SHA conflicts when pushing multiple files rapidly. The Git Trees API creates a single tree with all files and commits it atomically, avoiding race conditions entirely.

### Why Stubs Instead of Real shadcn Components
Installing real shadcn components requires running `npx shadcn@latest add` in a Node.js environment, which isn't available in Convex actions. Pre-built stubs with `forwardRef` div wrappers are sufficient for initial deploys. Self-heal can upgrade to real components later if needed.

### Why Two Scaffold Paths
The wizard path (`thin-client.ts`) generates context-aware scaffolds based on user selections (auth method, payment provider, API categories). The legacy path (`github.ts` inline) is a simpler fallback for backward compatibility when no wizard config is provided.
